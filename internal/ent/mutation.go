// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/PicoTools/pico/internal/ent/agent"
	"github.com/PicoTools/pico/internal/ent/blobber"
	"github.com/PicoTools/pico/internal/ent/chat"
	"github.com/PicoTools/pico/internal/ent/command"
	"github.com/PicoTools/pico/internal/ent/credential"
	"github.com/PicoTools/pico/internal/ent/listener"
	"github.com/PicoTools/pico/internal/ent/message"
	"github.com/PicoTools/pico/internal/ent/operator"
	"github.com/PicoTools/pico/internal/ent/pki"
	"github.com/PicoTools/pico/internal/ent/predicate"
	"github.com/PicoTools/pico/internal/ent/task"
	"github.com/PicoTools/pico/internal/types"
	"github.com/PicoTools/pico/pkg/shared"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAgent      = "Agent"
	TypeBlobber    = "Blobber"
	TypeChat       = "Chat"
	TypeCommand    = "Command"
	TypeCredential = "Credential"
	TypeListener   = "Listener"
	TypeMessage    = "Message"
	TypeOperator   = "Operator"
	TypePki        = "Pki"
	TypeTask       = "Task"
)

// AgentMutation represents an operation that mutates the Agent nodes in the graph.
type AgentMutation struct {
	config
	op              Op
	typ             string
	id              *uint32
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	ext_ip          *types.Inet
	int_ip          *types.Inet
	os              *shared.AgentOs
	os_meta         *string
	hostname        *string
	username        *string
	domain          *string
	privileged      *bool
	process_name    *string
	pid             *int64
	addpid          *int64
	arch            *shared.AgentArch
	sleep           *uint32
	addsleep        *int32
	jitter          *uint8
	addjitter       *int8
	first           *time.Time
	last            *time.Time
	caps            *uint32
	addcaps         *int32
	note            *string
	color           *uint32
	addcolor        *int32
	clearedFields   map[string]struct{}
	listener        *int64
	clearedlistener bool
	command         map[int64]struct{}
	removedcommand  map[int64]struct{}
	clearedcommand  bool
	task            map[int64]struct{}
	removedtask     map[int64]struct{}
	clearedtask     bool
	done            bool
	oldValue        func(context.Context) (*Agent, error)
	predicates      []predicate.Agent
}

var _ ent.Mutation = (*AgentMutation)(nil)

// agentOption allows management of the mutation configuration using functional options.
type agentOption func(*AgentMutation)

// newAgentMutation creates new mutation for the Agent entity.
func newAgentMutation(c config, op Op, opts ...agentOption) *AgentMutation {
	m := &AgentMutation{
		config:        c,
		op:            op,
		typ:           TypeAgent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgentID sets the ID field of the mutation.
func withAgentID(id uint32) agentOption {
	return func(m *AgentMutation) {
		var (
			err   error
			once  sync.Once
			value *Agent
		)
		m.oldValue = func(ctx context.Context) (*Agent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Agent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgent sets the old Agent of the mutation.
func withAgent(node *Agent) agentOption {
	return func(m *AgentMutation) {
		m.oldValue = func(context.Context) (*Agent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Agent entities.
func (m *AgentMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AgentMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AgentMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Agent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AgentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AgentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AgentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AgentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AgentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AgentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AgentMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AgentMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AgentMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[agent.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AgentMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[agent.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AgentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, agent.FieldDeletedAt)
}

// SetListenerID sets the "listener_id" field.
func (m *AgentMutation) SetListenerID(i int64) {
	m.listener = &i
}

// ListenerID returns the value of the "listener_id" field in the mutation.
func (m *AgentMutation) ListenerID() (r int64, exists bool) {
	v := m.listener
	if v == nil {
		return
	}
	return *v, true
}

// OldListenerID returns the old "listener_id" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldListenerID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldListenerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldListenerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldListenerID: %w", err)
	}
	return oldValue.ListenerID, nil
}

// ResetListenerID resets all changes to the "listener_id" field.
func (m *AgentMutation) ResetListenerID() {
	m.listener = nil
}

// SetExtIP sets the "ext_ip" field.
func (m *AgentMutation) SetExtIP(t types.Inet) {
	m.ext_ip = &t
}

// ExtIP returns the value of the "ext_ip" field in the mutation.
func (m *AgentMutation) ExtIP() (r types.Inet, exists bool) {
	v := m.ext_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldExtIP returns the old "ext_ip" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldExtIP(ctx context.Context) (v types.Inet, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtIP: %w", err)
	}
	return oldValue.ExtIP, nil
}

// ClearExtIP clears the value of the "ext_ip" field.
func (m *AgentMutation) ClearExtIP() {
	m.ext_ip = nil
	m.clearedFields[agent.FieldExtIP] = struct{}{}
}

// ExtIPCleared returns if the "ext_ip" field was cleared in this mutation.
func (m *AgentMutation) ExtIPCleared() bool {
	_, ok := m.clearedFields[agent.FieldExtIP]
	return ok
}

// ResetExtIP resets all changes to the "ext_ip" field.
func (m *AgentMutation) ResetExtIP() {
	m.ext_ip = nil
	delete(m.clearedFields, agent.FieldExtIP)
}

// SetIntIP sets the "int_ip" field.
func (m *AgentMutation) SetIntIP(t types.Inet) {
	m.int_ip = &t
}

// IntIP returns the value of the "int_ip" field in the mutation.
func (m *AgentMutation) IntIP() (r types.Inet, exists bool) {
	v := m.int_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIntIP returns the old "int_ip" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldIntIP(ctx context.Context) (v types.Inet, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntIP: %w", err)
	}
	return oldValue.IntIP, nil
}

// ClearIntIP clears the value of the "int_ip" field.
func (m *AgentMutation) ClearIntIP() {
	m.int_ip = nil
	m.clearedFields[agent.FieldIntIP] = struct{}{}
}

// IntIPCleared returns if the "int_ip" field was cleared in this mutation.
func (m *AgentMutation) IntIPCleared() bool {
	_, ok := m.clearedFields[agent.FieldIntIP]
	return ok
}

// ResetIntIP resets all changes to the "int_ip" field.
func (m *AgentMutation) ResetIntIP() {
	m.int_ip = nil
	delete(m.clearedFields, agent.FieldIntIP)
}

// SetOs sets the "os" field.
func (m *AgentMutation) SetOs(so shared.AgentOs) {
	m.os = &so
}

// Os returns the value of the "os" field in the mutation.
func (m *AgentMutation) Os() (r shared.AgentOs, exists bool) {
	v := m.os
	if v == nil {
		return
	}
	return *v, true
}

// OldOs returns the old "os" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldOs(ctx context.Context) (v shared.AgentOs, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOs: %w", err)
	}
	return oldValue.Os, nil
}

// ResetOs resets all changes to the "os" field.
func (m *AgentMutation) ResetOs() {
	m.os = nil
}

// SetOsMeta sets the "os_meta" field.
func (m *AgentMutation) SetOsMeta(s string) {
	m.os_meta = &s
}

// OsMeta returns the value of the "os_meta" field in the mutation.
func (m *AgentMutation) OsMeta() (r string, exists bool) {
	v := m.os_meta
	if v == nil {
		return
	}
	return *v, true
}

// OldOsMeta returns the old "os_meta" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldOsMeta(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOsMeta is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOsMeta requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOsMeta: %w", err)
	}
	return oldValue.OsMeta, nil
}

// ClearOsMeta clears the value of the "os_meta" field.
func (m *AgentMutation) ClearOsMeta() {
	m.os_meta = nil
	m.clearedFields[agent.FieldOsMeta] = struct{}{}
}

// OsMetaCleared returns if the "os_meta" field was cleared in this mutation.
func (m *AgentMutation) OsMetaCleared() bool {
	_, ok := m.clearedFields[agent.FieldOsMeta]
	return ok
}

// ResetOsMeta resets all changes to the "os_meta" field.
func (m *AgentMutation) ResetOsMeta() {
	m.os_meta = nil
	delete(m.clearedFields, agent.FieldOsMeta)
}

// SetHostname sets the "hostname" field.
func (m *AgentMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *AgentMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ClearHostname clears the value of the "hostname" field.
func (m *AgentMutation) ClearHostname() {
	m.hostname = nil
	m.clearedFields[agent.FieldHostname] = struct{}{}
}

// HostnameCleared returns if the "hostname" field was cleared in this mutation.
func (m *AgentMutation) HostnameCleared() bool {
	_, ok := m.clearedFields[agent.FieldHostname]
	return ok
}

// ResetHostname resets all changes to the "hostname" field.
func (m *AgentMutation) ResetHostname() {
	m.hostname = nil
	delete(m.clearedFields, agent.FieldHostname)
}

// SetUsername sets the "username" field.
func (m *AgentMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *AgentMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *AgentMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[agent.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *AgentMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[agent.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *AgentMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, agent.FieldUsername)
}

// SetDomain sets the "domain" field.
func (m *AgentMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *AgentMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ClearDomain clears the value of the "domain" field.
func (m *AgentMutation) ClearDomain() {
	m.domain = nil
	m.clearedFields[agent.FieldDomain] = struct{}{}
}

// DomainCleared returns if the "domain" field was cleared in this mutation.
func (m *AgentMutation) DomainCleared() bool {
	_, ok := m.clearedFields[agent.FieldDomain]
	return ok
}

// ResetDomain resets all changes to the "domain" field.
func (m *AgentMutation) ResetDomain() {
	m.domain = nil
	delete(m.clearedFields, agent.FieldDomain)
}

// SetPrivileged sets the "privileged" field.
func (m *AgentMutation) SetPrivileged(b bool) {
	m.privileged = &b
}

// Privileged returns the value of the "privileged" field in the mutation.
func (m *AgentMutation) Privileged() (r bool, exists bool) {
	v := m.privileged
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivileged returns the old "privileged" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldPrivileged(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivileged is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivileged requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivileged: %w", err)
	}
	return oldValue.Privileged, nil
}

// ClearPrivileged clears the value of the "privileged" field.
func (m *AgentMutation) ClearPrivileged() {
	m.privileged = nil
	m.clearedFields[agent.FieldPrivileged] = struct{}{}
}

// PrivilegedCleared returns if the "privileged" field was cleared in this mutation.
func (m *AgentMutation) PrivilegedCleared() bool {
	_, ok := m.clearedFields[agent.FieldPrivileged]
	return ok
}

// ResetPrivileged resets all changes to the "privileged" field.
func (m *AgentMutation) ResetPrivileged() {
	m.privileged = nil
	delete(m.clearedFields, agent.FieldPrivileged)
}

// SetProcessName sets the "process_name" field.
func (m *AgentMutation) SetProcessName(s string) {
	m.process_name = &s
}

// ProcessName returns the value of the "process_name" field in the mutation.
func (m *AgentMutation) ProcessName() (r string, exists bool) {
	v := m.process_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessName returns the old "process_name" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldProcessName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessName: %w", err)
	}
	return oldValue.ProcessName, nil
}

// ClearProcessName clears the value of the "process_name" field.
func (m *AgentMutation) ClearProcessName() {
	m.process_name = nil
	m.clearedFields[agent.FieldProcessName] = struct{}{}
}

// ProcessNameCleared returns if the "process_name" field was cleared in this mutation.
func (m *AgentMutation) ProcessNameCleared() bool {
	_, ok := m.clearedFields[agent.FieldProcessName]
	return ok
}

// ResetProcessName resets all changes to the "process_name" field.
func (m *AgentMutation) ResetProcessName() {
	m.process_name = nil
	delete(m.clearedFields, agent.FieldProcessName)
}

// SetPid sets the "pid" field.
func (m *AgentMutation) SetPid(i int64) {
	m.pid = &i
	m.addpid = nil
}

// Pid returns the value of the "pid" field in the mutation.
func (m *AgentMutation) Pid() (r int64, exists bool) {
	v := m.pid
	if v == nil {
		return
	}
	return *v, true
}

// OldPid returns the old "pid" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldPid(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPid: %w", err)
	}
	return oldValue.Pid, nil
}

// AddPid adds i to the "pid" field.
func (m *AgentMutation) AddPid(i int64) {
	if m.addpid != nil {
		*m.addpid += i
	} else {
		m.addpid = &i
	}
}

// AddedPid returns the value that was added to the "pid" field in this mutation.
func (m *AgentMutation) AddedPid() (r int64, exists bool) {
	v := m.addpid
	if v == nil {
		return
	}
	return *v, true
}

// ClearPid clears the value of the "pid" field.
func (m *AgentMutation) ClearPid() {
	m.pid = nil
	m.addpid = nil
	m.clearedFields[agent.FieldPid] = struct{}{}
}

// PidCleared returns if the "pid" field was cleared in this mutation.
func (m *AgentMutation) PidCleared() bool {
	_, ok := m.clearedFields[agent.FieldPid]
	return ok
}

// ResetPid resets all changes to the "pid" field.
func (m *AgentMutation) ResetPid() {
	m.pid = nil
	m.addpid = nil
	delete(m.clearedFields, agent.FieldPid)
}

// SetArch sets the "arch" field.
func (m *AgentMutation) SetArch(sa shared.AgentArch) {
	m.arch = &sa
}

// Arch returns the value of the "arch" field in the mutation.
func (m *AgentMutation) Arch() (r shared.AgentArch, exists bool) {
	v := m.arch
	if v == nil {
		return
	}
	return *v, true
}

// OldArch returns the old "arch" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldArch(ctx context.Context) (v shared.AgentArch, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArch: %w", err)
	}
	return oldValue.Arch, nil
}

// ResetArch resets all changes to the "arch" field.
func (m *AgentMutation) ResetArch() {
	m.arch = nil
}

// SetSleep sets the "sleep" field.
func (m *AgentMutation) SetSleep(u uint32) {
	m.sleep = &u
	m.addsleep = nil
}

// Sleep returns the value of the "sleep" field in the mutation.
func (m *AgentMutation) Sleep() (r uint32, exists bool) {
	v := m.sleep
	if v == nil {
		return
	}
	return *v, true
}

// OldSleep returns the old "sleep" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldSleep(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSleep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSleep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSleep: %w", err)
	}
	return oldValue.Sleep, nil
}

// AddSleep adds u to the "sleep" field.
func (m *AgentMutation) AddSleep(u int32) {
	if m.addsleep != nil {
		*m.addsleep += u
	} else {
		m.addsleep = &u
	}
}

// AddedSleep returns the value that was added to the "sleep" field in this mutation.
func (m *AgentMutation) AddedSleep() (r int32, exists bool) {
	v := m.addsleep
	if v == nil {
		return
	}
	return *v, true
}

// ResetSleep resets all changes to the "sleep" field.
func (m *AgentMutation) ResetSleep() {
	m.sleep = nil
	m.addsleep = nil
}

// SetJitter sets the "jitter" field.
func (m *AgentMutation) SetJitter(u uint8) {
	m.jitter = &u
	m.addjitter = nil
}

// Jitter returns the value of the "jitter" field in the mutation.
func (m *AgentMutation) Jitter() (r uint8, exists bool) {
	v := m.jitter
	if v == nil {
		return
	}
	return *v, true
}

// OldJitter returns the old "jitter" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldJitter(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJitter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJitter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJitter: %w", err)
	}
	return oldValue.Jitter, nil
}

// AddJitter adds u to the "jitter" field.
func (m *AgentMutation) AddJitter(u int8) {
	if m.addjitter != nil {
		*m.addjitter += u
	} else {
		m.addjitter = &u
	}
}

// AddedJitter returns the value that was added to the "jitter" field in this mutation.
func (m *AgentMutation) AddedJitter() (r int8, exists bool) {
	v := m.addjitter
	if v == nil {
		return
	}
	return *v, true
}

// ResetJitter resets all changes to the "jitter" field.
func (m *AgentMutation) ResetJitter() {
	m.jitter = nil
	m.addjitter = nil
}

// SetFirst sets the "first" field.
func (m *AgentMutation) SetFirst(t time.Time) {
	m.first = &t
}

// First returns the value of the "first" field in the mutation.
func (m *AgentMutation) First() (r time.Time, exists bool) {
	v := m.first
	if v == nil {
		return
	}
	return *v, true
}

// OldFirst returns the old "first" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldFirst(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirst is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirst requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirst: %w", err)
	}
	return oldValue.First, nil
}

// ResetFirst resets all changes to the "first" field.
func (m *AgentMutation) ResetFirst() {
	m.first = nil
}

// SetLast sets the "last" field.
func (m *AgentMutation) SetLast(t time.Time) {
	m.last = &t
}

// Last returns the value of the "last" field in the mutation.
func (m *AgentMutation) Last() (r time.Time, exists bool) {
	v := m.last
	if v == nil {
		return
	}
	return *v, true
}

// OldLast returns the old "last" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldLast(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLast is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLast requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLast: %w", err)
	}
	return oldValue.Last, nil
}

// ResetLast resets all changes to the "last" field.
func (m *AgentMutation) ResetLast() {
	m.last = nil
}

// SetCaps sets the "caps" field.
func (m *AgentMutation) SetCaps(u uint32) {
	m.caps = &u
	m.addcaps = nil
}

// Caps returns the value of the "caps" field in the mutation.
func (m *AgentMutation) Caps() (r uint32, exists bool) {
	v := m.caps
	if v == nil {
		return
	}
	return *v, true
}

// OldCaps returns the old "caps" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldCaps(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaps: %w", err)
	}
	return oldValue.Caps, nil
}

// AddCaps adds u to the "caps" field.
func (m *AgentMutation) AddCaps(u int32) {
	if m.addcaps != nil {
		*m.addcaps += u
	} else {
		m.addcaps = &u
	}
}

// AddedCaps returns the value that was added to the "caps" field in this mutation.
func (m *AgentMutation) AddedCaps() (r int32, exists bool) {
	v := m.addcaps
	if v == nil {
		return
	}
	return *v, true
}

// ResetCaps resets all changes to the "caps" field.
func (m *AgentMutation) ResetCaps() {
	m.caps = nil
	m.addcaps = nil
}

// SetNote sets the "note" field.
func (m *AgentMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *AgentMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *AgentMutation) ClearNote() {
	m.note = nil
	m.clearedFields[agent.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *AgentMutation) NoteCleared() bool {
	_, ok := m.clearedFields[agent.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *AgentMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, agent.FieldNote)
}

// SetColor sets the "color" field.
func (m *AgentMutation) SetColor(u uint32) {
	m.color = &u
	m.addcolor = nil
}

// Color returns the value of the "color" field in the mutation.
func (m *AgentMutation) Color() (r uint32, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldColor(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// AddColor adds u to the "color" field.
func (m *AgentMutation) AddColor(u int32) {
	if m.addcolor != nil {
		*m.addcolor += u
	} else {
		m.addcolor = &u
	}
}

// AddedColor returns the value that was added to the "color" field in this mutation.
func (m *AgentMutation) AddedColor() (r int32, exists bool) {
	v := m.addcolor
	if v == nil {
		return
	}
	return *v, true
}

// ResetColor resets all changes to the "color" field.
func (m *AgentMutation) ResetColor() {
	m.color = nil
	m.addcolor = nil
}

// ClearListener clears the "listener" edge to the Listener entity.
func (m *AgentMutation) ClearListener() {
	m.clearedlistener = true
	m.clearedFields[agent.FieldListenerID] = struct{}{}
}

// ListenerCleared reports if the "listener" edge to the Listener entity was cleared.
func (m *AgentMutation) ListenerCleared() bool {
	return m.clearedlistener
}

// ListenerIDs returns the "listener" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ListenerID instead. It exists only for internal usage by the builders.
func (m *AgentMutation) ListenerIDs() (ids []int64) {
	if id := m.listener; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetListener resets all changes to the "listener" edge.
func (m *AgentMutation) ResetListener() {
	m.listener = nil
	m.clearedlistener = false
}

// AddCommandIDs adds the "command" edge to the Command entity by ids.
func (m *AgentMutation) AddCommandIDs(ids ...int64) {
	if m.command == nil {
		m.command = make(map[int64]struct{})
	}
	for i := range ids {
		m.command[ids[i]] = struct{}{}
	}
}

// ClearCommand clears the "command" edge to the Command entity.
func (m *AgentMutation) ClearCommand() {
	m.clearedcommand = true
}

// CommandCleared reports if the "command" edge to the Command entity was cleared.
func (m *AgentMutation) CommandCleared() bool {
	return m.clearedcommand
}

// RemoveCommandIDs removes the "command" edge to the Command entity by IDs.
func (m *AgentMutation) RemoveCommandIDs(ids ...int64) {
	if m.removedcommand == nil {
		m.removedcommand = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.command, ids[i])
		m.removedcommand[ids[i]] = struct{}{}
	}
}

// RemovedCommand returns the removed IDs of the "command" edge to the Command entity.
func (m *AgentMutation) RemovedCommandIDs() (ids []int64) {
	for id := range m.removedcommand {
		ids = append(ids, id)
	}
	return
}

// CommandIDs returns the "command" edge IDs in the mutation.
func (m *AgentMutation) CommandIDs() (ids []int64) {
	for id := range m.command {
		ids = append(ids, id)
	}
	return
}

// ResetCommand resets all changes to the "command" edge.
func (m *AgentMutation) ResetCommand() {
	m.command = nil
	m.clearedcommand = false
	m.removedcommand = nil
}

// AddTaskIDs adds the "task" edge to the Task entity by ids.
func (m *AgentMutation) AddTaskIDs(ids ...int64) {
	if m.task == nil {
		m.task = make(map[int64]struct{})
	}
	for i := range ids {
		m.task[ids[i]] = struct{}{}
	}
}

// ClearTask clears the "task" edge to the Task entity.
func (m *AgentMutation) ClearTask() {
	m.clearedtask = true
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *AgentMutation) TaskCleared() bool {
	return m.clearedtask
}

// RemoveTaskIDs removes the "task" edge to the Task entity by IDs.
func (m *AgentMutation) RemoveTaskIDs(ids ...int64) {
	if m.removedtask == nil {
		m.removedtask = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.task, ids[i])
		m.removedtask[ids[i]] = struct{}{}
	}
}

// RemovedTask returns the removed IDs of the "task" edge to the Task entity.
func (m *AgentMutation) RemovedTaskIDs() (ids []int64) {
	for id := range m.removedtask {
		ids = append(ids, id)
	}
	return
}

// TaskIDs returns the "task" edge IDs in the mutation.
func (m *AgentMutation) TaskIDs() (ids []int64) {
	for id := range m.task {
		ids = append(ids, id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *AgentMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
	m.removedtask = nil
}

// Where appends a list predicates to the AgentMutation builder.
func (m *AgentMutation) Where(ps ...predicate.Agent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AgentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AgentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Agent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AgentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AgentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Agent).
func (m *AgentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgentMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.created_at != nil {
		fields = append(fields, agent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, agent.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, agent.FieldDeletedAt)
	}
	if m.listener != nil {
		fields = append(fields, agent.FieldListenerID)
	}
	if m.ext_ip != nil {
		fields = append(fields, agent.FieldExtIP)
	}
	if m.int_ip != nil {
		fields = append(fields, agent.FieldIntIP)
	}
	if m.os != nil {
		fields = append(fields, agent.FieldOs)
	}
	if m.os_meta != nil {
		fields = append(fields, agent.FieldOsMeta)
	}
	if m.hostname != nil {
		fields = append(fields, agent.FieldHostname)
	}
	if m.username != nil {
		fields = append(fields, agent.FieldUsername)
	}
	if m.domain != nil {
		fields = append(fields, agent.FieldDomain)
	}
	if m.privileged != nil {
		fields = append(fields, agent.FieldPrivileged)
	}
	if m.process_name != nil {
		fields = append(fields, agent.FieldProcessName)
	}
	if m.pid != nil {
		fields = append(fields, agent.FieldPid)
	}
	if m.arch != nil {
		fields = append(fields, agent.FieldArch)
	}
	if m.sleep != nil {
		fields = append(fields, agent.FieldSleep)
	}
	if m.jitter != nil {
		fields = append(fields, agent.FieldJitter)
	}
	if m.first != nil {
		fields = append(fields, agent.FieldFirst)
	}
	if m.last != nil {
		fields = append(fields, agent.FieldLast)
	}
	if m.caps != nil {
		fields = append(fields, agent.FieldCaps)
	}
	if m.note != nil {
		fields = append(fields, agent.FieldNote)
	}
	if m.color != nil {
		fields = append(fields, agent.FieldColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agent.FieldCreatedAt:
		return m.CreatedAt()
	case agent.FieldUpdatedAt:
		return m.UpdatedAt()
	case agent.FieldDeletedAt:
		return m.DeletedAt()
	case agent.FieldListenerID:
		return m.ListenerID()
	case agent.FieldExtIP:
		return m.ExtIP()
	case agent.FieldIntIP:
		return m.IntIP()
	case agent.FieldOs:
		return m.Os()
	case agent.FieldOsMeta:
		return m.OsMeta()
	case agent.FieldHostname:
		return m.Hostname()
	case agent.FieldUsername:
		return m.Username()
	case agent.FieldDomain:
		return m.Domain()
	case agent.FieldPrivileged:
		return m.Privileged()
	case agent.FieldProcessName:
		return m.ProcessName()
	case agent.FieldPid:
		return m.Pid()
	case agent.FieldArch:
		return m.Arch()
	case agent.FieldSleep:
		return m.Sleep()
	case agent.FieldJitter:
		return m.Jitter()
	case agent.FieldFirst:
		return m.First()
	case agent.FieldLast:
		return m.Last()
	case agent.FieldCaps:
		return m.Caps()
	case agent.FieldNote:
		return m.Note()
	case agent.FieldColor:
		return m.Color()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case agent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case agent.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case agent.FieldListenerID:
		return m.OldListenerID(ctx)
	case agent.FieldExtIP:
		return m.OldExtIP(ctx)
	case agent.FieldIntIP:
		return m.OldIntIP(ctx)
	case agent.FieldOs:
		return m.OldOs(ctx)
	case agent.FieldOsMeta:
		return m.OldOsMeta(ctx)
	case agent.FieldHostname:
		return m.OldHostname(ctx)
	case agent.FieldUsername:
		return m.OldUsername(ctx)
	case agent.FieldDomain:
		return m.OldDomain(ctx)
	case agent.FieldPrivileged:
		return m.OldPrivileged(ctx)
	case agent.FieldProcessName:
		return m.OldProcessName(ctx)
	case agent.FieldPid:
		return m.OldPid(ctx)
	case agent.FieldArch:
		return m.OldArch(ctx)
	case agent.FieldSleep:
		return m.OldSleep(ctx)
	case agent.FieldJitter:
		return m.OldJitter(ctx)
	case agent.FieldFirst:
		return m.OldFirst(ctx)
	case agent.FieldLast:
		return m.OldLast(ctx)
	case agent.FieldCaps:
		return m.OldCaps(ctx)
	case agent.FieldNote:
		return m.OldNote(ctx)
	case agent.FieldColor:
		return m.OldColor(ctx)
	}
	return nil, fmt.Errorf("unknown Agent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case agent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case agent.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case agent.FieldListenerID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetListenerID(v)
		return nil
	case agent.FieldExtIP:
		v, ok := value.(types.Inet)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtIP(v)
		return nil
	case agent.FieldIntIP:
		v, ok := value.(types.Inet)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntIP(v)
		return nil
	case agent.FieldOs:
		v, ok := value.(shared.AgentOs)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOs(v)
		return nil
	case agent.FieldOsMeta:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOsMeta(v)
		return nil
	case agent.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case agent.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case agent.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case agent.FieldPrivileged:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivileged(v)
		return nil
	case agent.FieldProcessName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessName(v)
		return nil
	case agent.FieldPid:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPid(v)
		return nil
	case agent.FieldArch:
		v, ok := value.(shared.AgentArch)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArch(v)
		return nil
	case agent.FieldSleep:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSleep(v)
		return nil
	case agent.FieldJitter:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJitter(v)
		return nil
	case agent.FieldFirst:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirst(v)
		return nil
	case agent.FieldLast:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLast(v)
		return nil
	case agent.FieldCaps:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaps(v)
		return nil
	case agent.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case agent.FieldColor:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	}
	return fmt.Errorf("unknown Agent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgentMutation) AddedFields() []string {
	var fields []string
	if m.addpid != nil {
		fields = append(fields, agent.FieldPid)
	}
	if m.addsleep != nil {
		fields = append(fields, agent.FieldSleep)
	}
	if m.addjitter != nil {
		fields = append(fields, agent.FieldJitter)
	}
	if m.addcaps != nil {
		fields = append(fields, agent.FieldCaps)
	}
	if m.addcolor != nil {
		fields = append(fields, agent.FieldColor)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case agent.FieldPid:
		return m.AddedPid()
	case agent.FieldSleep:
		return m.AddedSleep()
	case agent.FieldJitter:
		return m.AddedJitter()
	case agent.FieldCaps:
		return m.AddedCaps()
	case agent.FieldColor:
		return m.AddedColor()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case agent.FieldPid:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPid(v)
		return nil
	case agent.FieldSleep:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSleep(v)
		return nil
	case agent.FieldJitter:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddJitter(v)
		return nil
	case agent.FieldCaps:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCaps(v)
		return nil
	case agent.FieldColor:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddColor(v)
		return nil
	}
	return fmt.Errorf("unknown Agent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(agent.FieldDeletedAt) {
		fields = append(fields, agent.FieldDeletedAt)
	}
	if m.FieldCleared(agent.FieldExtIP) {
		fields = append(fields, agent.FieldExtIP)
	}
	if m.FieldCleared(agent.FieldIntIP) {
		fields = append(fields, agent.FieldIntIP)
	}
	if m.FieldCleared(agent.FieldOsMeta) {
		fields = append(fields, agent.FieldOsMeta)
	}
	if m.FieldCleared(agent.FieldHostname) {
		fields = append(fields, agent.FieldHostname)
	}
	if m.FieldCleared(agent.FieldUsername) {
		fields = append(fields, agent.FieldUsername)
	}
	if m.FieldCleared(agent.FieldDomain) {
		fields = append(fields, agent.FieldDomain)
	}
	if m.FieldCleared(agent.FieldPrivileged) {
		fields = append(fields, agent.FieldPrivileged)
	}
	if m.FieldCleared(agent.FieldProcessName) {
		fields = append(fields, agent.FieldProcessName)
	}
	if m.FieldCleared(agent.FieldPid) {
		fields = append(fields, agent.FieldPid)
	}
	if m.FieldCleared(agent.FieldNote) {
		fields = append(fields, agent.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgentMutation) ClearField(name string) error {
	switch name {
	case agent.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case agent.FieldExtIP:
		m.ClearExtIP()
		return nil
	case agent.FieldIntIP:
		m.ClearIntIP()
		return nil
	case agent.FieldOsMeta:
		m.ClearOsMeta()
		return nil
	case agent.FieldHostname:
		m.ClearHostname()
		return nil
	case agent.FieldUsername:
		m.ClearUsername()
		return nil
	case agent.FieldDomain:
		m.ClearDomain()
		return nil
	case agent.FieldPrivileged:
		m.ClearPrivileged()
		return nil
	case agent.FieldProcessName:
		m.ClearProcessName()
		return nil
	case agent.FieldPid:
		m.ClearPid()
		return nil
	case agent.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown Agent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgentMutation) ResetField(name string) error {
	switch name {
	case agent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case agent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case agent.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case agent.FieldListenerID:
		m.ResetListenerID()
		return nil
	case agent.FieldExtIP:
		m.ResetExtIP()
		return nil
	case agent.FieldIntIP:
		m.ResetIntIP()
		return nil
	case agent.FieldOs:
		m.ResetOs()
		return nil
	case agent.FieldOsMeta:
		m.ResetOsMeta()
		return nil
	case agent.FieldHostname:
		m.ResetHostname()
		return nil
	case agent.FieldUsername:
		m.ResetUsername()
		return nil
	case agent.FieldDomain:
		m.ResetDomain()
		return nil
	case agent.FieldPrivileged:
		m.ResetPrivileged()
		return nil
	case agent.FieldProcessName:
		m.ResetProcessName()
		return nil
	case agent.FieldPid:
		m.ResetPid()
		return nil
	case agent.FieldArch:
		m.ResetArch()
		return nil
	case agent.FieldSleep:
		m.ResetSleep()
		return nil
	case agent.FieldJitter:
		m.ResetJitter()
		return nil
	case agent.FieldFirst:
		m.ResetFirst()
		return nil
	case agent.FieldLast:
		m.ResetLast()
		return nil
	case agent.FieldCaps:
		m.ResetCaps()
		return nil
	case agent.FieldNote:
		m.ResetNote()
		return nil
	case agent.FieldColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown Agent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.listener != nil {
		edges = append(edges, agent.EdgeListener)
	}
	if m.command != nil {
		edges = append(edges, agent.EdgeCommand)
	}
	if m.task != nil {
		edges = append(edges, agent.EdgeTask)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case agent.EdgeListener:
		if id := m.listener; id != nil {
			return []ent.Value{*id}
		}
	case agent.EdgeCommand:
		ids := make([]ent.Value, 0, len(m.command))
		for id := range m.command {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeTask:
		ids := make([]ent.Value, 0, len(m.task))
		for id := range m.task {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcommand != nil {
		edges = append(edges, agent.EdgeCommand)
	}
	if m.removedtask != nil {
		edges = append(edges, agent.EdgeTask)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case agent.EdgeCommand:
		ids := make([]ent.Value, 0, len(m.removedcommand))
		for id := range m.removedcommand {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeTask:
		ids := make([]ent.Value, 0, len(m.removedtask))
		for id := range m.removedtask {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedlistener {
		edges = append(edges, agent.EdgeListener)
	}
	if m.clearedcommand {
		edges = append(edges, agent.EdgeCommand)
	}
	if m.clearedtask {
		edges = append(edges, agent.EdgeTask)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgentMutation) EdgeCleared(name string) bool {
	switch name {
	case agent.EdgeListener:
		return m.clearedlistener
	case agent.EdgeCommand:
		return m.clearedcommand
	case agent.EdgeTask:
		return m.clearedtask
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgentMutation) ClearEdge(name string) error {
	switch name {
	case agent.EdgeListener:
		m.ClearListener()
		return nil
	}
	return fmt.Errorf("unknown Agent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgentMutation) ResetEdge(name string) error {
	switch name {
	case agent.EdgeListener:
		m.ResetListener()
		return nil
	case agent.EdgeCommand:
		m.ResetCommand()
		return nil
	case agent.EdgeTask:
		m.ResetTask()
		return nil
	}
	return fmt.Errorf("unknown Agent edge %s", name)
}

// BlobberMutation represents an operation that mutates the Blobber nodes in the graph.
type BlobberMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	hash               *[]byte
	blob               *[]byte
	size               *int
	addsize            *int
	clearedFields      map[string]struct{}
	task_args          map[int64]struct{}
	removedtask_args   map[int64]struct{}
	clearedtask_args   bool
	task_output        map[int64]struct{}
	removedtask_output map[int64]struct{}
	clearedtask_output bool
	done               bool
	oldValue           func(context.Context) (*Blobber, error)
	predicates         []predicate.Blobber
}

var _ ent.Mutation = (*BlobberMutation)(nil)

// blobberOption allows management of the mutation configuration using functional options.
type blobberOption func(*BlobberMutation)

// newBlobberMutation creates new mutation for the Blobber entity.
func newBlobberMutation(c config, op Op, opts ...blobberOption) *BlobberMutation {
	m := &BlobberMutation{
		config:        c,
		op:            op,
		typ:           TypeBlobber,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlobberID sets the ID field of the mutation.
func withBlobberID(id int) blobberOption {
	return func(m *BlobberMutation) {
		var (
			err   error
			once  sync.Once
			value *Blobber
		)
		m.oldValue = func(ctx context.Context) (*Blobber, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Blobber.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlobber sets the old Blobber of the mutation.
func withBlobber(node *Blobber) blobberOption {
	return func(m *BlobberMutation) {
		m.oldValue = func(context.Context) (*Blobber, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlobberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlobberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlobberMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlobberMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Blobber.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BlobberMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlobberMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Blobber entity.
// If the Blobber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlobberMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlobberMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlobberMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlobberMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Blobber entity.
// If the Blobber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlobberMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlobberMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BlobberMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BlobberMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Blobber entity.
// If the Blobber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlobberMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BlobberMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[blobber.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BlobberMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[blobber.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BlobberMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, blobber.FieldDeletedAt)
}

// SetHash sets the "hash" field.
func (m *BlobberMutation) SetHash(b []byte) {
	m.hash = &b
}

// Hash returns the value of the "hash" field in the mutation.
func (m *BlobberMutation) Hash() (r []byte, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the Blobber entity.
// If the Blobber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlobberMutation) OldHash(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *BlobberMutation) ResetHash() {
	m.hash = nil
}

// SetBlob sets the "blob" field.
func (m *BlobberMutation) SetBlob(b []byte) {
	m.blob = &b
}

// Blob returns the value of the "blob" field in the mutation.
func (m *BlobberMutation) Blob() (r []byte, exists bool) {
	v := m.blob
	if v == nil {
		return
	}
	return *v, true
}

// OldBlob returns the old "blob" field's value of the Blobber entity.
// If the Blobber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlobberMutation) OldBlob(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlob is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlob requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlob: %w", err)
	}
	return oldValue.Blob, nil
}

// ResetBlob resets all changes to the "blob" field.
func (m *BlobberMutation) ResetBlob() {
	m.blob = nil
}

// SetSize sets the "size" field.
func (m *BlobberMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *BlobberMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Blobber entity.
// If the Blobber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlobberMutation) OldSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *BlobberMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *BlobberMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *BlobberMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// AddTaskArgIDs adds the "task_args" edge to the Task entity by ids.
func (m *BlobberMutation) AddTaskArgIDs(ids ...int64) {
	if m.task_args == nil {
		m.task_args = make(map[int64]struct{})
	}
	for i := range ids {
		m.task_args[ids[i]] = struct{}{}
	}
}

// ClearTaskArgs clears the "task_args" edge to the Task entity.
func (m *BlobberMutation) ClearTaskArgs() {
	m.clearedtask_args = true
}

// TaskArgsCleared reports if the "task_args" edge to the Task entity was cleared.
func (m *BlobberMutation) TaskArgsCleared() bool {
	return m.clearedtask_args
}

// RemoveTaskArgIDs removes the "task_args" edge to the Task entity by IDs.
func (m *BlobberMutation) RemoveTaskArgIDs(ids ...int64) {
	if m.removedtask_args == nil {
		m.removedtask_args = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.task_args, ids[i])
		m.removedtask_args[ids[i]] = struct{}{}
	}
}

// RemovedTaskArgs returns the removed IDs of the "task_args" edge to the Task entity.
func (m *BlobberMutation) RemovedTaskArgsIDs() (ids []int64) {
	for id := range m.removedtask_args {
		ids = append(ids, id)
	}
	return
}

// TaskArgsIDs returns the "task_args" edge IDs in the mutation.
func (m *BlobberMutation) TaskArgsIDs() (ids []int64) {
	for id := range m.task_args {
		ids = append(ids, id)
	}
	return
}

// ResetTaskArgs resets all changes to the "task_args" edge.
func (m *BlobberMutation) ResetTaskArgs() {
	m.task_args = nil
	m.clearedtask_args = false
	m.removedtask_args = nil
}

// AddTaskOutputIDs adds the "task_output" edge to the Task entity by ids.
func (m *BlobberMutation) AddTaskOutputIDs(ids ...int64) {
	if m.task_output == nil {
		m.task_output = make(map[int64]struct{})
	}
	for i := range ids {
		m.task_output[ids[i]] = struct{}{}
	}
}

// ClearTaskOutput clears the "task_output" edge to the Task entity.
func (m *BlobberMutation) ClearTaskOutput() {
	m.clearedtask_output = true
}

// TaskOutputCleared reports if the "task_output" edge to the Task entity was cleared.
func (m *BlobberMutation) TaskOutputCleared() bool {
	return m.clearedtask_output
}

// RemoveTaskOutputIDs removes the "task_output" edge to the Task entity by IDs.
func (m *BlobberMutation) RemoveTaskOutputIDs(ids ...int64) {
	if m.removedtask_output == nil {
		m.removedtask_output = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.task_output, ids[i])
		m.removedtask_output[ids[i]] = struct{}{}
	}
}

// RemovedTaskOutput returns the removed IDs of the "task_output" edge to the Task entity.
func (m *BlobberMutation) RemovedTaskOutputIDs() (ids []int64) {
	for id := range m.removedtask_output {
		ids = append(ids, id)
	}
	return
}

// TaskOutputIDs returns the "task_output" edge IDs in the mutation.
func (m *BlobberMutation) TaskOutputIDs() (ids []int64) {
	for id := range m.task_output {
		ids = append(ids, id)
	}
	return
}

// ResetTaskOutput resets all changes to the "task_output" edge.
func (m *BlobberMutation) ResetTaskOutput() {
	m.task_output = nil
	m.clearedtask_output = false
	m.removedtask_output = nil
}

// Where appends a list predicates to the BlobberMutation builder.
func (m *BlobberMutation) Where(ps ...predicate.Blobber) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlobberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlobberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Blobber, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlobberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlobberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Blobber).
func (m *BlobberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlobberMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, blobber.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blobber.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, blobber.FieldDeletedAt)
	}
	if m.hash != nil {
		fields = append(fields, blobber.FieldHash)
	}
	if m.blob != nil {
		fields = append(fields, blobber.FieldBlob)
	}
	if m.size != nil {
		fields = append(fields, blobber.FieldSize)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlobberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blobber.FieldCreatedAt:
		return m.CreatedAt()
	case blobber.FieldUpdatedAt:
		return m.UpdatedAt()
	case blobber.FieldDeletedAt:
		return m.DeletedAt()
	case blobber.FieldHash:
		return m.Hash()
	case blobber.FieldBlob:
		return m.Blob()
	case blobber.FieldSize:
		return m.Size()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlobberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blobber.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blobber.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case blobber.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case blobber.FieldHash:
		return m.OldHash(ctx)
	case blobber.FieldBlob:
		return m.OldBlob(ctx)
	case blobber.FieldSize:
		return m.OldSize(ctx)
	}
	return nil, fmt.Errorf("unknown Blobber field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlobberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blobber.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blobber.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case blobber.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case blobber.FieldHash:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case blobber.FieldBlob:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlob(v)
		return nil
	case blobber.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	}
	return fmt.Errorf("unknown Blobber field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlobberMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, blobber.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlobberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blobber.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlobberMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blobber.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown Blobber numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlobberMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blobber.FieldDeletedAt) {
		fields = append(fields, blobber.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlobberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlobberMutation) ClearField(name string) error {
	switch name {
	case blobber.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Blobber nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlobberMutation) ResetField(name string) error {
	switch name {
	case blobber.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blobber.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case blobber.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case blobber.FieldHash:
		m.ResetHash()
		return nil
	case blobber.FieldBlob:
		m.ResetBlob()
		return nil
	case blobber.FieldSize:
		m.ResetSize()
		return nil
	}
	return fmt.Errorf("unknown Blobber field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlobberMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.task_args != nil {
		edges = append(edges, blobber.EdgeTaskArgs)
	}
	if m.task_output != nil {
		edges = append(edges, blobber.EdgeTaskOutput)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlobberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blobber.EdgeTaskArgs:
		ids := make([]ent.Value, 0, len(m.task_args))
		for id := range m.task_args {
			ids = append(ids, id)
		}
		return ids
	case blobber.EdgeTaskOutput:
		ids := make([]ent.Value, 0, len(m.task_output))
		for id := range m.task_output {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlobberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtask_args != nil {
		edges = append(edges, blobber.EdgeTaskArgs)
	}
	if m.removedtask_output != nil {
		edges = append(edges, blobber.EdgeTaskOutput)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlobberMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case blobber.EdgeTaskArgs:
		ids := make([]ent.Value, 0, len(m.removedtask_args))
		for id := range m.removedtask_args {
			ids = append(ids, id)
		}
		return ids
	case blobber.EdgeTaskOutput:
		ids := make([]ent.Value, 0, len(m.removedtask_output))
		for id := range m.removedtask_output {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlobberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtask_args {
		edges = append(edges, blobber.EdgeTaskArgs)
	}
	if m.clearedtask_output {
		edges = append(edges, blobber.EdgeTaskOutput)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlobberMutation) EdgeCleared(name string) bool {
	switch name {
	case blobber.EdgeTaskArgs:
		return m.clearedtask_args
	case blobber.EdgeTaskOutput:
		return m.clearedtask_output
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlobberMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Blobber unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlobberMutation) ResetEdge(name string) error {
	switch name {
	case blobber.EdgeTaskArgs:
		m.ResetTaskArgs()
		return nil
	case blobber.EdgeTaskOutput:
		m.ResetTaskOutput()
		return nil
	}
	return fmt.Errorf("unknown Blobber edge %s", name)
}

// ChatMutation represents an operation that mutates the Chat nodes in the graph.
type ChatMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	message         *string
	is_server       *bool
	clearedFields   map[string]struct{}
	operator        *int64
	clearedoperator bool
	done            bool
	oldValue        func(context.Context) (*Chat, error)
	predicates      []predicate.Chat
}

var _ ent.Mutation = (*ChatMutation)(nil)

// chatOption allows management of the mutation configuration using functional options.
type chatOption func(*ChatMutation)

// newChatMutation creates new mutation for the Chat entity.
func newChatMutation(c config, op Op, opts ...chatOption) *ChatMutation {
	m := &ChatMutation{
		config:        c,
		op:            op,
		typ:           TypeChat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChatID sets the ID field of the mutation.
func withChatID(id int) chatOption {
	return func(m *ChatMutation) {
		var (
			err   error
			once  sync.Once
			value *Chat
		)
		m.oldValue = func(ctx context.Context) (*Chat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Chat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChat sets the old Chat of the mutation.
func withChat(node *Chat) chatOption {
	return func(m *ChatMutation) {
		m.oldValue = func(context.Context) (*Chat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChatMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChatMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Chat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ChatMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChatMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Chat entity.
// If the Chat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChatMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetAuthorID sets the "author_id" field.
func (m *ChatMutation) SetAuthorID(i int64) {
	m.operator = &i
}

// AuthorID returns the value of the "author_id" field in the mutation.
func (m *ChatMutation) AuthorID() (r int64, exists bool) {
	v := m.operator
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorID returns the old "author_id" field's value of the Chat entity.
// If the Chat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatMutation) OldAuthorID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorID: %w", err)
	}
	return oldValue.AuthorID, nil
}

// ClearAuthorID clears the value of the "author_id" field.
func (m *ChatMutation) ClearAuthorID() {
	m.operator = nil
	m.clearedFields[chat.FieldAuthorID] = struct{}{}
}

// AuthorIDCleared returns if the "author_id" field was cleared in this mutation.
func (m *ChatMutation) AuthorIDCleared() bool {
	_, ok := m.clearedFields[chat.FieldAuthorID]
	return ok
}

// ResetAuthorID resets all changes to the "author_id" field.
func (m *ChatMutation) ResetAuthorID() {
	m.operator = nil
	delete(m.clearedFields, chat.FieldAuthorID)
}

// SetMessage sets the "message" field.
func (m *ChatMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *ChatMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Chat entity.
// If the Chat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *ChatMutation) ResetMessage() {
	m.message = nil
}

// SetIsServer sets the "is_server" field.
func (m *ChatMutation) SetIsServer(b bool) {
	m.is_server = &b
}

// IsServer returns the value of the "is_server" field in the mutation.
func (m *ChatMutation) IsServer() (r bool, exists bool) {
	v := m.is_server
	if v == nil {
		return
	}
	return *v, true
}

// OldIsServer returns the old "is_server" field's value of the Chat entity.
// If the Chat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatMutation) OldIsServer(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsServer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsServer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsServer: %w", err)
	}
	return oldValue.IsServer, nil
}

// ResetIsServer resets all changes to the "is_server" field.
func (m *ChatMutation) ResetIsServer() {
	m.is_server = nil
}

// SetOperatorID sets the "operator" edge to the Operator entity by id.
func (m *ChatMutation) SetOperatorID(id int64) {
	m.operator = &id
}

// ClearOperator clears the "operator" edge to the Operator entity.
func (m *ChatMutation) ClearOperator() {
	m.clearedoperator = true
	m.clearedFields[chat.FieldAuthorID] = struct{}{}
}

// OperatorCleared reports if the "operator" edge to the Operator entity was cleared.
func (m *ChatMutation) OperatorCleared() bool {
	return m.AuthorIDCleared() || m.clearedoperator
}

// OperatorID returns the "operator" edge ID in the mutation.
func (m *ChatMutation) OperatorID() (id int64, exists bool) {
	if m.operator != nil {
		return *m.operator, true
	}
	return
}

// OperatorIDs returns the "operator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OperatorID instead. It exists only for internal usage by the builders.
func (m *ChatMutation) OperatorIDs() (ids []int64) {
	if id := m.operator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOperator resets all changes to the "operator" edge.
func (m *ChatMutation) ResetOperator() {
	m.operator = nil
	m.clearedoperator = false
}

// Where appends a list predicates to the ChatMutation builder.
func (m *ChatMutation) Where(ps ...predicate.Chat) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChatMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChatMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Chat, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChatMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChatMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Chat).
func (m *ChatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChatMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, chat.FieldCreatedAt)
	}
	if m.operator != nil {
		fields = append(fields, chat.FieldAuthorID)
	}
	if m.message != nil {
		fields = append(fields, chat.FieldMessage)
	}
	if m.is_server != nil {
		fields = append(fields, chat.FieldIsServer)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChatMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case chat.FieldCreatedAt:
		return m.CreatedAt()
	case chat.FieldAuthorID:
		return m.AuthorID()
	case chat.FieldMessage:
		return m.Message()
	case chat.FieldIsServer:
		return m.IsServer()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case chat.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case chat.FieldAuthorID:
		return m.OldAuthorID(ctx)
	case chat.FieldMessage:
		return m.OldMessage(ctx)
	case chat.FieldIsServer:
		return m.OldIsServer(ctx)
	}
	return nil, fmt.Errorf("unknown Chat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChatMutation) SetField(name string, value ent.Value) error {
	switch name {
	case chat.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case chat.FieldAuthorID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorID(v)
		return nil
	case chat.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case chat.FieldIsServer:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsServer(v)
		return nil
	}
	return fmt.Errorf("unknown Chat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChatMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChatMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChatMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Chat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChatMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(chat.FieldAuthorID) {
		fields = append(fields, chat.FieldAuthorID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChatMutation) ClearField(name string) error {
	switch name {
	case chat.FieldAuthorID:
		m.ClearAuthorID()
		return nil
	}
	return fmt.Errorf("unknown Chat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChatMutation) ResetField(name string) error {
	switch name {
	case chat.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case chat.FieldAuthorID:
		m.ResetAuthorID()
		return nil
	case chat.FieldMessage:
		m.ResetMessage()
		return nil
	case chat.FieldIsServer:
		m.ResetIsServer()
		return nil
	}
	return fmt.Errorf("unknown Chat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChatMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.operator != nil {
		edges = append(edges, chat.EdgeOperator)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChatMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case chat.EdgeOperator:
		if id := m.operator; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChatMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedoperator {
		edges = append(edges, chat.EdgeOperator)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChatMutation) EdgeCleared(name string) bool {
	switch name {
	case chat.EdgeOperator:
		return m.clearedoperator
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChatMutation) ClearEdge(name string) error {
	switch name {
	case chat.EdgeOperator:
		m.ClearOperator()
		return nil
	}
	return fmt.Errorf("unknown Chat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChatMutation) ResetEdge(name string) error {
	switch name {
	case chat.EdgeOperator:
		m.ResetOperator()
		return nil
	}
	return fmt.Errorf("unknown Chat edge %s", name)
}

// CommandMutation represents an operation that mutates the Command nodes in the graph.
type CommandMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	cmd             *string
	visible         *bool
	created_at      *time.Time
	closed_at       *time.Time
	clearedFields   map[string]struct{}
	agent           *uint32
	clearedagent    bool
	operator        *int64
	clearedoperator bool
	message         map[int]struct{}
	removedmessage  map[int]struct{}
	clearedmessage  bool
	task            map[int64]struct{}
	removedtask     map[int64]struct{}
	clearedtask     bool
	done            bool
	oldValue        func(context.Context) (*Command, error)
	predicates      []predicate.Command
}

var _ ent.Mutation = (*CommandMutation)(nil)

// commandOption allows management of the mutation configuration using functional options.
type commandOption func(*CommandMutation)

// newCommandMutation creates new mutation for the Command entity.
func newCommandMutation(c config, op Op, opts ...commandOption) *CommandMutation {
	m := &CommandMutation{
		config:        c,
		op:            op,
		typ:           TypeCommand,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommandID sets the ID field of the mutation.
func withCommandID(id int64) commandOption {
	return func(m *CommandMutation) {
		var (
			err   error
			once  sync.Once
			value *Command
		)
		m.oldValue = func(ctx context.Context) (*Command, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Command.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommand sets the old Command of the mutation.
func withCommand(node *Command) commandOption {
	return func(m *CommandMutation) {
		m.oldValue = func(context.Context) (*Command, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommandMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommandMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Command entities.
func (m *CommandMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommandMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommandMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Command.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAgentID sets the "agent_id" field.
func (m *CommandMutation) SetAgentID(u uint32) {
	m.agent = &u
}

// AgentID returns the value of the "agent_id" field in the mutation.
func (m *CommandMutation) AgentID() (r uint32, exists bool) {
	v := m.agent
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentID returns the old "agent_id" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldAgentID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentID: %w", err)
	}
	return oldValue.AgentID, nil
}

// ResetAgentID resets all changes to the "agent_id" field.
func (m *CommandMutation) ResetAgentID() {
	m.agent = nil
}

// SetCmd sets the "cmd" field.
func (m *CommandMutation) SetCmd(s string) {
	m.cmd = &s
}

// Cmd returns the value of the "cmd" field in the mutation.
func (m *CommandMutation) Cmd() (r string, exists bool) {
	v := m.cmd
	if v == nil {
		return
	}
	return *v, true
}

// OldCmd returns the old "cmd" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldCmd(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCmd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCmd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCmd: %w", err)
	}
	return oldValue.Cmd, nil
}

// ResetCmd resets all changes to the "cmd" field.
func (m *CommandMutation) ResetCmd() {
	m.cmd = nil
}

// SetVisible sets the "visible" field.
func (m *CommandMutation) SetVisible(b bool) {
	m.visible = &b
}

// Visible returns the value of the "visible" field in the mutation.
func (m *CommandMutation) Visible() (r bool, exists bool) {
	v := m.visible
	if v == nil {
		return
	}
	return *v, true
}

// OldVisible returns the old "visible" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldVisible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisible: %w", err)
	}
	return oldValue.Visible, nil
}

// ResetVisible resets all changes to the "visible" field.
func (m *CommandMutation) ResetVisible() {
	m.visible = nil
}

// SetAuthorID sets the "author_id" field.
func (m *CommandMutation) SetAuthorID(i int64) {
	m.operator = &i
}

// AuthorID returns the value of the "author_id" field in the mutation.
func (m *CommandMutation) AuthorID() (r int64, exists bool) {
	v := m.operator
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorID returns the old "author_id" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldAuthorID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorID: %w", err)
	}
	return oldValue.AuthorID, nil
}

// ResetAuthorID resets all changes to the "author_id" field.
func (m *CommandMutation) ResetAuthorID() {
	m.operator = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CommandMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommandMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommandMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetClosedAt sets the "closed_at" field.
func (m *CommandMutation) SetClosedAt(t time.Time) {
	m.closed_at = &t
}

// ClosedAt returns the value of the "closed_at" field in the mutation.
func (m *CommandMutation) ClosedAt() (r time.Time, exists bool) {
	v := m.closed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldClosedAt returns the old "closed_at" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldClosedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClosedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClosedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClosedAt: %w", err)
	}
	return oldValue.ClosedAt, nil
}

// ClearClosedAt clears the value of the "closed_at" field.
func (m *CommandMutation) ClearClosedAt() {
	m.closed_at = nil
	m.clearedFields[command.FieldClosedAt] = struct{}{}
}

// ClosedAtCleared returns if the "closed_at" field was cleared in this mutation.
func (m *CommandMutation) ClosedAtCleared() bool {
	_, ok := m.clearedFields[command.FieldClosedAt]
	return ok
}

// ResetClosedAt resets all changes to the "closed_at" field.
func (m *CommandMutation) ResetClosedAt() {
	m.closed_at = nil
	delete(m.clearedFields, command.FieldClosedAt)
}

// ClearAgent clears the "agent" edge to the Agent entity.
func (m *CommandMutation) ClearAgent() {
	m.clearedagent = true
	m.clearedFields[command.FieldAgentID] = struct{}{}
}

// AgentCleared reports if the "agent" edge to the Agent entity was cleared.
func (m *CommandMutation) AgentCleared() bool {
	return m.clearedagent
}

// AgentIDs returns the "agent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentID instead. It exists only for internal usage by the builders.
func (m *CommandMutation) AgentIDs() (ids []uint32) {
	if id := m.agent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgent resets all changes to the "agent" edge.
func (m *CommandMutation) ResetAgent() {
	m.agent = nil
	m.clearedagent = false
}

// SetOperatorID sets the "operator" edge to the Operator entity by id.
func (m *CommandMutation) SetOperatorID(id int64) {
	m.operator = &id
}

// ClearOperator clears the "operator" edge to the Operator entity.
func (m *CommandMutation) ClearOperator() {
	m.clearedoperator = true
	m.clearedFields[command.FieldAuthorID] = struct{}{}
}

// OperatorCleared reports if the "operator" edge to the Operator entity was cleared.
func (m *CommandMutation) OperatorCleared() bool {
	return m.clearedoperator
}

// OperatorID returns the "operator" edge ID in the mutation.
func (m *CommandMutation) OperatorID() (id int64, exists bool) {
	if m.operator != nil {
		return *m.operator, true
	}
	return
}

// OperatorIDs returns the "operator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OperatorID instead. It exists only for internal usage by the builders.
func (m *CommandMutation) OperatorIDs() (ids []int64) {
	if id := m.operator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOperator resets all changes to the "operator" edge.
func (m *CommandMutation) ResetOperator() {
	m.operator = nil
	m.clearedoperator = false
}

// AddMessageIDs adds the "message" edge to the Message entity by ids.
func (m *CommandMutation) AddMessageIDs(ids ...int) {
	if m.message == nil {
		m.message = make(map[int]struct{})
	}
	for i := range ids {
		m.message[ids[i]] = struct{}{}
	}
}

// ClearMessage clears the "message" edge to the Message entity.
func (m *CommandMutation) ClearMessage() {
	m.clearedmessage = true
}

// MessageCleared reports if the "message" edge to the Message entity was cleared.
func (m *CommandMutation) MessageCleared() bool {
	return m.clearedmessage
}

// RemoveMessageIDs removes the "message" edge to the Message entity by IDs.
func (m *CommandMutation) RemoveMessageIDs(ids ...int) {
	if m.removedmessage == nil {
		m.removedmessage = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.message, ids[i])
		m.removedmessage[ids[i]] = struct{}{}
	}
}

// RemovedMessage returns the removed IDs of the "message" edge to the Message entity.
func (m *CommandMutation) RemovedMessageIDs() (ids []int) {
	for id := range m.removedmessage {
		ids = append(ids, id)
	}
	return
}

// MessageIDs returns the "message" edge IDs in the mutation.
func (m *CommandMutation) MessageIDs() (ids []int) {
	for id := range m.message {
		ids = append(ids, id)
	}
	return
}

// ResetMessage resets all changes to the "message" edge.
func (m *CommandMutation) ResetMessage() {
	m.message = nil
	m.clearedmessage = false
	m.removedmessage = nil
}

// AddTaskIDs adds the "task" edge to the Task entity by ids.
func (m *CommandMutation) AddTaskIDs(ids ...int64) {
	if m.task == nil {
		m.task = make(map[int64]struct{})
	}
	for i := range ids {
		m.task[ids[i]] = struct{}{}
	}
}

// ClearTask clears the "task" edge to the Task entity.
func (m *CommandMutation) ClearTask() {
	m.clearedtask = true
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *CommandMutation) TaskCleared() bool {
	return m.clearedtask
}

// RemoveTaskIDs removes the "task" edge to the Task entity by IDs.
func (m *CommandMutation) RemoveTaskIDs(ids ...int64) {
	if m.removedtask == nil {
		m.removedtask = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.task, ids[i])
		m.removedtask[ids[i]] = struct{}{}
	}
}

// RemovedTask returns the removed IDs of the "task" edge to the Task entity.
func (m *CommandMutation) RemovedTaskIDs() (ids []int64) {
	for id := range m.removedtask {
		ids = append(ids, id)
	}
	return
}

// TaskIDs returns the "task" edge IDs in the mutation.
func (m *CommandMutation) TaskIDs() (ids []int64) {
	for id := range m.task {
		ids = append(ids, id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *CommandMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
	m.removedtask = nil
}

// Where appends a list predicates to the CommandMutation builder.
func (m *CommandMutation) Where(ps ...predicate.Command) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommandMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommandMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Command, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommandMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommandMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Command).
func (m *CommandMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommandMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.agent != nil {
		fields = append(fields, command.FieldAgentID)
	}
	if m.cmd != nil {
		fields = append(fields, command.FieldCmd)
	}
	if m.visible != nil {
		fields = append(fields, command.FieldVisible)
	}
	if m.operator != nil {
		fields = append(fields, command.FieldAuthorID)
	}
	if m.created_at != nil {
		fields = append(fields, command.FieldCreatedAt)
	}
	if m.closed_at != nil {
		fields = append(fields, command.FieldClosedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommandMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case command.FieldAgentID:
		return m.AgentID()
	case command.FieldCmd:
		return m.Cmd()
	case command.FieldVisible:
		return m.Visible()
	case command.FieldAuthorID:
		return m.AuthorID()
	case command.FieldCreatedAt:
		return m.CreatedAt()
	case command.FieldClosedAt:
		return m.ClosedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommandMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case command.FieldAgentID:
		return m.OldAgentID(ctx)
	case command.FieldCmd:
		return m.OldCmd(ctx)
	case command.FieldVisible:
		return m.OldVisible(ctx)
	case command.FieldAuthorID:
		return m.OldAuthorID(ctx)
	case command.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case command.FieldClosedAt:
		return m.OldClosedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Command field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommandMutation) SetField(name string, value ent.Value) error {
	switch name {
	case command.FieldAgentID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentID(v)
		return nil
	case command.FieldCmd:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCmd(v)
		return nil
	case command.FieldVisible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisible(v)
		return nil
	case command.FieldAuthorID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorID(v)
		return nil
	case command.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case command.FieldClosedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClosedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Command field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommandMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommandMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommandMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Command numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommandMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(command.FieldClosedAt) {
		fields = append(fields, command.FieldClosedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommandMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommandMutation) ClearField(name string) error {
	switch name {
	case command.FieldClosedAt:
		m.ClearClosedAt()
		return nil
	}
	return fmt.Errorf("unknown Command nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommandMutation) ResetField(name string) error {
	switch name {
	case command.FieldAgentID:
		m.ResetAgentID()
		return nil
	case command.FieldCmd:
		m.ResetCmd()
		return nil
	case command.FieldVisible:
		m.ResetVisible()
		return nil
	case command.FieldAuthorID:
		m.ResetAuthorID()
		return nil
	case command.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case command.FieldClosedAt:
		m.ResetClosedAt()
		return nil
	}
	return fmt.Errorf("unknown Command field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommandMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.agent != nil {
		edges = append(edges, command.EdgeAgent)
	}
	if m.operator != nil {
		edges = append(edges, command.EdgeOperator)
	}
	if m.message != nil {
		edges = append(edges, command.EdgeMessage)
	}
	if m.task != nil {
		edges = append(edges, command.EdgeTask)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommandMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case command.EdgeAgent:
		if id := m.agent; id != nil {
			return []ent.Value{*id}
		}
	case command.EdgeOperator:
		if id := m.operator; id != nil {
			return []ent.Value{*id}
		}
	case command.EdgeMessage:
		ids := make([]ent.Value, 0, len(m.message))
		for id := range m.message {
			ids = append(ids, id)
		}
		return ids
	case command.EdgeTask:
		ids := make([]ent.Value, 0, len(m.task))
		for id := range m.task {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommandMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedmessage != nil {
		edges = append(edges, command.EdgeMessage)
	}
	if m.removedtask != nil {
		edges = append(edges, command.EdgeTask)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommandMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case command.EdgeMessage:
		ids := make([]ent.Value, 0, len(m.removedmessage))
		for id := range m.removedmessage {
			ids = append(ids, id)
		}
		return ids
	case command.EdgeTask:
		ids := make([]ent.Value, 0, len(m.removedtask))
		for id := range m.removedtask {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommandMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedagent {
		edges = append(edges, command.EdgeAgent)
	}
	if m.clearedoperator {
		edges = append(edges, command.EdgeOperator)
	}
	if m.clearedmessage {
		edges = append(edges, command.EdgeMessage)
	}
	if m.clearedtask {
		edges = append(edges, command.EdgeTask)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommandMutation) EdgeCleared(name string) bool {
	switch name {
	case command.EdgeAgent:
		return m.clearedagent
	case command.EdgeOperator:
		return m.clearedoperator
	case command.EdgeMessage:
		return m.clearedmessage
	case command.EdgeTask:
		return m.clearedtask
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommandMutation) ClearEdge(name string) error {
	switch name {
	case command.EdgeAgent:
		m.ClearAgent()
		return nil
	case command.EdgeOperator:
		m.ClearOperator()
		return nil
	}
	return fmt.Errorf("unknown Command unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommandMutation) ResetEdge(name string) error {
	switch name {
	case command.EdgeAgent:
		m.ResetAgent()
		return nil
	case command.EdgeOperator:
		m.ResetOperator()
		return nil
	case command.EdgeMessage:
		m.ResetMessage()
		return nil
	case command.EdgeTask:
		m.ResetTask()
		return nil
	}
	return fmt.Errorf("unknown Command edge %s", name)
}

// CredentialMutation represents an operation that mutates the Credential nodes in the graph.
type CredentialMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	username      *string
	secret        *string
	realm         *string
	host          *string
	note          *string
	color         *uint32
	addcolor      *int32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Credential, error)
	predicates    []predicate.Credential
}

var _ ent.Mutation = (*CredentialMutation)(nil)

// credentialOption allows management of the mutation configuration using functional options.
type credentialOption func(*CredentialMutation)

// newCredentialMutation creates new mutation for the Credential entity.
func newCredentialMutation(c config, op Op, opts ...credentialOption) *CredentialMutation {
	m := &CredentialMutation{
		config:        c,
		op:            op,
		typ:           TypeCredential,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCredentialID sets the ID field of the mutation.
func withCredentialID(id int64) credentialOption {
	return func(m *CredentialMutation) {
		var (
			err   error
			once  sync.Once
			value *Credential
		)
		m.oldValue = func(ctx context.Context) (*Credential, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Credential.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCredential sets the old Credential of the mutation.
func withCredential(node *Credential) credentialOption {
	return func(m *CredentialMutation) {
		m.oldValue = func(context.Context) (*Credential, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CredentialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CredentialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Credential entities.
func (m *CredentialMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CredentialMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CredentialMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Credential.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CredentialMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CredentialMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CredentialMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CredentialMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CredentialMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CredentialMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CredentialMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CredentialMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CredentialMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[credential.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CredentialMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[credential.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CredentialMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, credential.FieldDeletedAt)
}

// SetUsername sets the "username" field.
func (m *CredentialMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *CredentialMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *CredentialMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[credential.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *CredentialMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[credential.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *CredentialMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, credential.FieldUsername)
}

// SetSecret sets the "secret" field.
func (m *CredentialMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the value of the "secret" field in the mutation.
func (m *CredentialMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ClearSecret clears the value of the "secret" field.
func (m *CredentialMutation) ClearSecret() {
	m.secret = nil
	m.clearedFields[credential.FieldSecret] = struct{}{}
}

// SecretCleared returns if the "secret" field was cleared in this mutation.
func (m *CredentialMutation) SecretCleared() bool {
	_, ok := m.clearedFields[credential.FieldSecret]
	return ok
}

// ResetSecret resets all changes to the "secret" field.
func (m *CredentialMutation) ResetSecret() {
	m.secret = nil
	delete(m.clearedFields, credential.FieldSecret)
}

// SetRealm sets the "realm" field.
func (m *CredentialMutation) SetRealm(s string) {
	m.realm = &s
}

// Realm returns the value of the "realm" field in the mutation.
func (m *CredentialMutation) Realm() (r string, exists bool) {
	v := m.realm
	if v == nil {
		return
	}
	return *v, true
}

// OldRealm returns the old "realm" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldRealm(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRealm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRealm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRealm: %w", err)
	}
	return oldValue.Realm, nil
}

// ClearRealm clears the value of the "realm" field.
func (m *CredentialMutation) ClearRealm() {
	m.realm = nil
	m.clearedFields[credential.FieldRealm] = struct{}{}
}

// RealmCleared returns if the "realm" field was cleared in this mutation.
func (m *CredentialMutation) RealmCleared() bool {
	_, ok := m.clearedFields[credential.FieldRealm]
	return ok
}

// ResetRealm resets all changes to the "realm" field.
func (m *CredentialMutation) ResetRealm() {
	m.realm = nil
	delete(m.clearedFields, credential.FieldRealm)
}

// SetHost sets the "host" field.
func (m *CredentialMutation) SetHost(s string) {
	m.host = &s
}

// Host returns the value of the "host" field in the mutation.
func (m *CredentialMutation) Host() (r string, exists bool) {
	v := m.host
	if v == nil {
		return
	}
	return *v, true
}

// OldHost returns the old "host" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldHost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHost: %w", err)
	}
	return oldValue.Host, nil
}

// ClearHost clears the value of the "host" field.
func (m *CredentialMutation) ClearHost() {
	m.host = nil
	m.clearedFields[credential.FieldHost] = struct{}{}
}

// HostCleared returns if the "host" field was cleared in this mutation.
func (m *CredentialMutation) HostCleared() bool {
	_, ok := m.clearedFields[credential.FieldHost]
	return ok
}

// ResetHost resets all changes to the "host" field.
func (m *CredentialMutation) ResetHost() {
	m.host = nil
	delete(m.clearedFields, credential.FieldHost)
}

// SetNote sets the "note" field.
func (m *CredentialMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *CredentialMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *CredentialMutation) ClearNote() {
	m.note = nil
	m.clearedFields[credential.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *CredentialMutation) NoteCleared() bool {
	_, ok := m.clearedFields[credential.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *CredentialMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, credential.FieldNote)
}

// SetColor sets the "color" field.
func (m *CredentialMutation) SetColor(u uint32) {
	m.color = &u
	m.addcolor = nil
}

// Color returns the value of the "color" field in the mutation.
func (m *CredentialMutation) Color() (r uint32, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldColor(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// AddColor adds u to the "color" field.
func (m *CredentialMutation) AddColor(u int32) {
	if m.addcolor != nil {
		*m.addcolor += u
	} else {
		m.addcolor = &u
	}
}

// AddedColor returns the value that was added to the "color" field in this mutation.
func (m *CredentialMutation) AddedColor() (r int32, exists bool) {
	v := m.addcolor
	if v == nil {
		return
	}
	return *v, true
}

// ResetColor resets all changes to the "color" field.
func (m *CredentialMutation) ResetColor() {
	m.color = nil
	m.addcolor = nil
}

// Where appends a list predicates to the CredentialMutation builder.
func (m *CredentialMutation) Where(ps ...predicate.Credential) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CredentialMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CredentialMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Credential, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CredentialMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CredentialMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Credential).
func (m *CredentialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CredentialMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, credential.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, credential.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, credential.FieldDeletedAt)
	}
	if m.username != nil {
		fields = append(fields, credential.FieldUsername)
	}
	if m.secret != nil {
		fields = append(fields, credential.FieldSecret)
	}
	if m.realm != nil {
		fields = append(fields, credential.FieldRealm)
	}
	if m.host != nil {
		fields = append(fields, credential.FieldHost)
	}
	if m.note != nil {
		fields = append(fields, credential.FieldNote)
	}
	if m.color != nil {
		fields = append(fields, credential.FieldColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CredentialMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case credential.FieldCreatedAt:
		return m.CreatedAt()
	case credential.FieldUpdatedAt:
		return m.UpdatedAt()
	case credential.FieldDeletedAt:
		return m.DeletedAt()
	case credential.FieldUsername:
		return m.Username()
	case credential.FieldSecret:
		return m.Secret()
	case credential.FieldRealm:
		return m.Realm()
	case credential.FieldHost:
		return m.Host()
	case credential.FieldNote:
		return m.Note()
	case credential.FieldColor:
		return m.Color()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CredentialMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case credential.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case credential.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case credential.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case credential.FieldUsername:
		return m.OldUsername(ctx)
	case credential.FieldSecret:
		return m.OldSecret(ctx)
	case credential.FieldRealm:
		return m.OldRealm(ctx)
	case credential.FieldHost:
		return m.OldHost(ctx)
	case credential.FieldNote:
		return m.OldNote(ctx)
	case credential.FieldColor:
		return m.OldColor(ctx)
	}
	return nil, fmt.Errorf("unknown Credential field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CredentialMutation) SetField(name string, value ent.Value) error {
	switch name {
	case credential.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case credential.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case credential.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case credential.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case credential.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case credential.FieldRealm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRealm(v)
		return nil
	case credential.FieldHost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHost(v)
		return nil
	case credential.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case credential.FieldColor:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	}
	return fmt.Errorf("unknown Credential field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CredentialMutation) AddedFields() []string {
	var fields []string
	if m.addcolor != nil {
		fields = append(fields, credential.FieldColor)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CredentialMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case credential.FieldColor:
		return m.AddedColor()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CredentialMutation) AddField(name string, value ent.Value) error {
	switch name {
	case credential.FieldColor:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddColor(v)
		return nil
	}
	return fmt.Errorf("unknown Credential numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CredentialMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(credential.FieldDeletedAt) {
		fields = append(fields, credential.FieldDeletedAt)
	}
	if m.FieldCleared(credential.FieldUsername) {
		fields = append(fields, credential.FieldUsername)
	}
	if m.FieldCleared(credential.FieldSecret) {
		fields = append(fields, credential.FieldSecret)
	}
	if m.FieldCleared(credential.FieldRealm) {
		fields = append(fields, credential.FieldRealm)
	}
	if m.FieldCleared(credential.FieldHost) {
		fields = append(fields, credential.FieldHost)
	}
	if m.FieldCleared(credential.FieldNote) {
		fields = append(fields, credential.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CredentialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CredentialMutation) ClearField(name string) error {
	switch name {
	case credential.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case credential.FieldUsername:
		m.ClearUsername()
		return nil
	case credential.FieldSecret:
		m.ClearSecret()
		return nil
	case credential.FieldRealm:
		m.ClearRealm()
		return nil
	case credential.FieldHost:
		m.ClearHost()
		return nil
	case credential.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown Credential nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CredentialMutation) ResetField(name string) error {
	switch name {
	case credential.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case credential.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case credential.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case credential.FieldUsername:
		m.ResetUsername()
		return nil
	case credential.FieldSecret:
		m.ResetSecret()
		return nil
	case credential.FieldRealm:
		m.ResetRealm()
		return nil
	case credential.FieldHost:
		m.ResetHost()
		return nil
	case credential.FieldNote:
		m.ResetNote()
		return nil
	case credential.FieldColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown Credential field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CredentialMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CredentialMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CredentialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CredentialMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CredentialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CredentialMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CredentialMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Credential unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CredentialMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Credential edge %s", name)
}

// ListenerMutation represents an operation that mutates the Listener nodes in the graph.
type ListenerMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	token         *string
	name          *string
	ip            *types.Inet
	port          *uint16
	addport       *int16
	color         *uint32
	addcolor      *int32
	note          *string
	last          *time.Time
	clearedFields map[string]struct{}
	agent         map[uint32]struct{}
	removedagent  map[uint32]struct{}
	clearedagent  bool
	done          bool
	oldValue      func(context.Context) (*Listener, error)
	predicates    []predicate.Listener
}

var _ ent.Mutation = (*ListenerMutation)(nil)

// listenerOption allows management of the mutation configuration using functional options.
type listenerOption func(*ListenerMutation)

// newListenerMutation creates new mutation for the Listener entity.
func newListenerMutation(c config, op Op, opts ...listenerOption) *ListenerMutation {
	m := &ListenerMutation{
		config:        c,
		op:            op,
		typ:           TypeListener,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withListenerID sets the ID field of the mutation.
func withListenerID(id int64) listenerOption {
	return func(m *ListenerMutation) {
		var (
			err   error
			once  sync.Once
			value *Listener
		)
		m.oldValue = func(ctx context.Context) (*Listener, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Listener.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withListener sets the old Listener of the mutation.
func withListener(node *Listener) listenerOption {
	return func(m *ListenerMutation) {
		m.oldValue = func(context.Context) (*Listener, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ListenerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ListenerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Listener entities.
func (m *ListenerMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ListenerMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ListenerMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Listener.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ListenerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ListenerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Listener entity.
// If the Listener object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ListenerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ListenerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ListenerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Listener entity.
// If the Listener object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ListenerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ListenerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ListenerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Listener entity.
// If the Listener object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenerMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ListenerMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[listener.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ListenerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[listener.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ListenerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, listener.FieldDeletedAt)
}

// SetToken sets the "token" field.
func (m *ListenerMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *ListenerMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Listener entity.
// If the Listener object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenerMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ClearToken clears the value of the "token" field.
func (m *ListenerMutation) ClearToken() {
	m.token = nil
	m.clearedFields[listener.FieldToken] = struct{}{}
}

// TokenCleared returns if the "token" field was cleared in this mutation.
func (m *ListenerMutation) TokenCleared() bool {
	_, ok := m.clearedFields[listener.FieldToken]
	return ok
}

// ResetToken resets all changes to the "token" field.
func (m *ListenerMutation) ResetToken() {
	m.token = nil
	delete(m.clearedFields, listener.FieldToken)
}

// SetName sets the "name" field.
func (m *ListenerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ListenerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Listener entity.
// If the Listener object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ListenerMutation) ClearName() {
	m.name = nil
	m.clearedFields[listener.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ListenerMutation) NameCleared() bool {
	_, ok := m.clearedFields[listener.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ListenerMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, listener.FieldName)
}

// SetIP sets the "ip" field.
func (m *ListenerMutation) SetIP(t types.Inet) {
	m.ip = &t
}

// IP returns the value of the "ip" field in the mutation.
func (m *ListenerMutation) IP() (r types.Inet, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the Listener entity.
// If the Listener object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenerMutation) OldIP(ctx context.Context) (v types.Inet, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ClearIP clears the value of the "ip" field.
func (m *ListenerMutation) ClearIP() {
	m.ip = nil
	m.clearedFields[listener.FieldIP] = struct{}{}
}

// IPCleared returns if the "ip" field was cleared in this mutation.
func (m *ListenerMutation) IPCleared() bool {
	_, ok := m.clearedFields[listener.FieldIP]
	return ok
}

// ResetIP resets all changes to the "ip" field.
func (m *ListenerMutation) ResetIP() {
	m.ip = nil
	delete(m.clearedFields, listener.FieldIP)
}

// SetPort sets the "port" field.
func (m *ListenerMutation) SetPort(u uint16) {
	m.port = &u
	m.addport = nil
}

// Port returns the value of the "port" field in the mutation.
func (m *ListenerMutation) Port() (r uint16, exists bool) {
	v := m.port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old "port" field's value of the Listener entity.
// If the Listener object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenerMutation) OldPort(ctx context.Context) (v uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// AddPort adds u to the "port" field.
func (m *ListenerMutation) AddPort(u int16) {
	if m.addport != nil {
		*m.addport += u
	} else {
		m.addport = &u
	}
}

// AddedPort returns the value that was added to the "port" field in this mutation.
func (m *ListenerMutation) AddedPort() (r int16, exists bool) {
	v := m.addport
	if v == nil {
		return
	}
	return *v, true
}

// ClearPort clears the value of the "port" field.
func (m *ListenerMutation) ClearPort() {
	m.port = nil
	m.addport = nil
	m.clearedFields[listener.FieldPort] = struct{}{}
}

// PortCleared returns if the "port" field was cleared in this mutation.
func (m *ListenerMutation) PortCleared() bool {
	_, ok := m.clearedFields[listener.FieldPort]
	return ok
}

// ResetPort resets all changes to the "port" field.
func (m *ListenerMutation) ResetPort() {
	m.port = nil
	m.addport = nil
	delete(m.clearedFields, listener.FieldPort)
}

// SetColor sets the "color" field.
func (m *ListenerMutation) SetColor(u uint32) {
	m.color = &u
	m.addcolor = nil
}

// Color returns the value of the "color" field in the mutation.
func (m *ListenerMutation) Color() (r uint32, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Listener entity.
// If the Listener object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenerMutation) OldColor(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// AddColor adds u to the "color" field.
func (m *ListenerMutation) AddColor(u int32) {
	if m.addcolor != nil {
		*m.addcolor += u
	} else {
		m.addcolor = &u
	}
}

// AddedColor returns the value that was added to the "color" field in this mutation.
func (m *ListenerMutation) AddedColor() (r int32, exists bool) {
	v := m.addcolor
	if v == nil {
		return
	}
	return *v, true
}

// ResetColor resets all changes to the "color" field.
func (m *ListenerMutation) ResetColor() {
	m.color = nil
	m.addcolor = nil
}

// SetNote sets the "note" field.
func (m *ListenerMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *ListenerMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Listener entity.
// If the Listener object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenerMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *ListenerMutation) ClearNote() {
	m.note = nil
	m.clearedFields[listener.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *ListenerMutation) NoteCleared() bool {
	_, ok := m.clearedFields[listener.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *ListenerMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, listener.FieldNote)
}

// SetLast sets the "last" field.
func (m *ListenerMutation) SetLast(t time.Time) {
	m.last = &t
}

// Last returns the value of the "last" field in the mutation.
func (m *ListenerMutation) Last() (r time.Time, exists bool) {
	v := m.last
	if v == nil {
		return
	}
	return *v, true
}

// OldLast returns the old "last" field's value of the Listener entity.
// If the Listener object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ListenerMutation) OldLast(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLast is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLast requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLast: %w", err)
	}
	return oldValue.Last, nil
}

// ResetLast resets all changes to the "last" field.
func (m *ListenerMutation) ResetLast() {
	m.last = nil
}

// AddAgentIDs adds the "agent" edge to the Agent entity by ids.
func (m *ListenerMutation) AddAgentIDs(ids ...uint32) {
	if m.agent == nil {
		m.agent = make(map[uint32]struct{})
	}
	for i := range ids {
		m.agent[ids[i]] = struct{}{}
	}
}

// ClearAgent clears the "agent" edge to the Agent entity.
func (m *ListenerMutation) ClearAgent() {
	m.clearedagent = true
}

// AgentCleared reports if the "agent" edge to the Agent entity was cleared.
func (m *ListenerMutation) AgentCleared() bool {
	return m.clearedagent
}

// RemoveAgentIDs removes the "agent" edge to the Agent entity by IDs.
func (m *ListenerMutation) RemoveAgentIDs(ids ...uint32) {
	if m.removedagent == nil {
		m.removedagent = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.agent, ids[i])
		m.removedagent[ids[i]] = struct{}{}
	}
}

// RemovedAgent returns the removed IDs of the "agent" edge to the Agent entity.
func (m *ListenerMutation) RemovedAgentIDs() (ids []uint32) {
	for id := range m.removedagent {
		ids = append(ids, id)
	}
	return
}

// AgentIDs returns the "agent" edge IDs in the mutation.
func (m *ListenerMutation) AgentIDs() (ids []uint32) {
	for id := range m.agent {
		ids = append(ids, id)
	}
	return
}

// ResetAgent resets all changes to the "agent" edge.
func (m *ListenerMutation) ResetAgent() {
	m.agent = nil
	m.clearedagent = false
	m.removedagent = nil
}

// Where appends a list predicates to the ListenerMutation builder.
func (m *ListenerMutation) Where(ps ...predicate.Listener) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ListenerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ListenerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Listener, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ListenerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ListenerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Listener).
func (m *ListenerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ListenerMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, listener.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, listener.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, listener.FieldDeletedAt)
	}
	if m.token != nil {
		fields = append(fields, listener.FieldToken)
	}
	if m.name != nil {
		fields = append(fields, listener.FieldName)
	}
	if m.ip != nil {
		fields = append(fields, listener.FieldIP)
	}
	if m.port != nil {
		fields = append(fields, listener.FieldPort)
	}
	if m.color != nil {
		fields = append(fields, listener.FieldColor)
	}
	if m.note != nil {
		fields = append(fields, listener.FieldNote)
	}
	if m.last != nil {
		fields = append(fields, listener.FieldLast)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ListenerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case listener.FieldCreatedAt:
		return m.CreatedAt()
	case listener.FieldUpdatedAt:
		return m.UpdatedAt()
	case listener.FieldDeletedAt:
		return m.DeletedAt()
	case listener.FieldToken:
		return m.Token()
	case listener.FieldName:
		return m.Name()
	case listener.FieldIP:
		return m.IP()
	case listener.FieldPort:
		return m.Port()
	case listener.FieldColor:
		return m.Color()
	case listener.FieldNote:
		return m.Note()
	case listener.FieldLast:
		return m.Last()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ListenerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case listener.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case listener.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case listener.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case listener.FieldToken:
		return m.OldToken(ctx)
	case listener.FieldName:
		return m.OldName(ctx)
	case listener.FieldIP:
		return m.OldIP(ctx)
	case listener.FieldPort:
		return m.OldPort(ctx)
	case listener.FieldColor:
		return m.OldColor(ctx)
	case listener.FieldNote:
		return m.OldNote(ctx)
	case listener.FieldLast:
		return m.OldLast(ctx)
	}
	return nil, fmt.Errorf("unknown Listener field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ListenerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case listener.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case listener.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case listener.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case listener.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case listener.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case listener.FieldIP:
		v, ok := value.(types.Inet)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case listener.FieldPort:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	case listener.FieldColor:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case listener.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case listener.FieldLast:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLast(v)
		return nil
	}
	return fmt.Errorf("unknown Listener field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ListenerMutation) AddedFields() []string {
	var fields []string
	if m.addport != nil {
		fields = append(fields, listener.FieldPort)
	}
	if m.addcolor != nil {
		fields = append(fields, listener.FieldColor)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ListenerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case listener.FieldPort:
		return m.AddedPort()
	case listener.FieldColor:
		return m.AddedColor()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ListenerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case listener.FieldPort:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPort(v)
		return nil
	case listener.FieldColor:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddColor(v)
		return nil
	}
	return fmt.Errorf("unknown Listener numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ListenerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(listener.FieldDeletedAt) {
		fields = append(fields, listener.FieldDeletedAt)
	}
	if m.FieldCleared(listener.FieldToken) {
		fields = append(fields, listener.FieldToken)
	}
	if m.FieldCleared(listener.FieldName) {
		fields = append(fields, listener.FieldName)
	}
	if m.FieldCleared(listener.FieldIP) {
		fields = append(fields, listener.FieldIP)
	}
	if m.FieldCleared(listener.FieldPort) {
		fields = append(fields, listener.FieldPort)
	}
	if m.FieldCleared(listener.FieldNote) {
		fields = append(fields, listener.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ListenerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ListenerMutation) ClearField(name string) error {
	switch name {
	case listener.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case listener.FieldToken:
		m.ClearToken()
		return nil
	case listener.FieldName:
		m.ClearName()
		return nil
	case listener.FieldIP:
		m.ClearIP()
		return nil
	case listener.FieldPort:
		m.ClearPort()
		return nil
	case listener.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown Listener nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ListenerMutation) ResetField(name string) error {
	switch name {
	case listener.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case listener.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case listener.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case listener.FieldToken:
		m.ResetToken()
		return nil
	case listener.FieldName:
		m.ResetName()
		return nil
	case listener.FieldIP:
		m.ResetIP()
		return nil
	case listener.FieldPort:
		m.ResetPort()
		return nil
	case listener.FieldColor:
		m.ResetColor()
		return nil
	case listener.FieldNote:
		m.ResetNote()
		return nil
	case listener.FieldLast:
		m.ResetLast()
		return nil
	}
	return fmt.Errorf("unknown Listener field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ListenerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.agent != nil {
		edges = append(edges, listener.EdgeAgent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ListenerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case listener.EdgeAgent:
		ids := make([]ent.Value, 0, len(m.agent))
		for id := range m.agent {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ListenerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedagent != nil {
		edges = append(edges, listener.EdgeAgent)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ListenerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case listener.EdgeAgent:
		ids := make([]ent.Value, 0, len(m.removedagent))
		for id := range m.removedagent {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ListenerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedagent {
		edges = append(edges, listener.EdgeAgent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ListenerMutation) EdgeCleared(name string) bool {
	switch name {
	case listener.EdgeAgent:
		return m.clearedagent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ListenerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Listener unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ListenerMutation) ResetEdge(name string) error {
	switch name {
	case listener.EdgeAgent:
		m.ResetAgent()
		return nil
	}
	return fmt.Errorf("unknown Listener edge %s", name)
}

// MessageMutation represents an operation that mutates the Message nodes in the graph.
type MessageMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_type          *shared.TaskMessage
	message        *string
	created_at     *time.Time
	clearedFields  map[string]struct{}
	command        *int64
	clearedcommand bool
	done           bool
	oldValue       func(context.Context) (*Message, error)
	predicates     []predicate.Message
}

var _ ent.Mutation = (*MessageMutation)(nil)

// messageOption allows management of the mutation configuration using functional options.
type messageOption func(*MessageMutation)

// newMessageMutation creates new mutation for the Message entity.
func newMessageMutation(c config, op Op, opts ...messageOption) *MessageMutation {
	m := &MessageMutation{
		config:        c,
		op:            op,
		typ:           TypeMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageID sets the ID field of the mutation.
func withMessageID(id int) messageOption {
	return func(m *MessageMutation) {
		var (
			err   error
			once  sync.Once
			value *Message
		)
		m.oldValue = func(ctx context.Context) (*Message, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Message.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessage sets the old Message of the mutation.
func withMessage(node *Message) messageOption {
	return func(m *MessageMutation) {
		m.oldValue = func(context.Context) (*Message, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Message.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCommandID sets the "command_id" field.
func (m *MessageMutation) SetCommandID(i int64) {
	m.command = &i
}

// CommandID returns the value of the "command_id" field in the mutation.
func (m *MessageMutation) CommandID() (r int64, exists bool) {
	v := m.command
	if v == nil {
		return
	}
	return *v, true
}

// OldCommandID returns the old "command_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldCommandID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommandID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommandID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommandID: %w", err)
	}
	return oldValue.CommandID, nil
}

// ResetCommandID resets all changes to the "command_id" field.
func (m *MessageMutation) ResetCommandID() {
	m.command = nil
}

// SetType sets the "type" field.
func (m *MessageMutation) SetType(sm shared.TaskMessage) {
	m._type = &sm
}

// GetType returns the value of the "type" field in the mutation.
func (m *MessageMutation) GetType() (r shared.TaskMessage, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldType(ctx context.Context) (v shared.TaskMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MessageMutation) ResetType() {
	m._type = nil
}

// SetMessage sets the "message" field.
func (m *MessageMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *MessageMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *MessageMutation) ResetMessage() {
	m.message = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearCommand clears the "command" edge to the Command entity.
func (m *MessageMutation) ClearCommand() {
	m.clearedcommand = true
	m.clearedFields[message.FieldCommandID] = struct{}{}
}

// CommandCleared reports if the "command" edge to the Command entity was cleared.
func (m *MessageMutation) CommandCleared() bool {
	return m.clearedcommand
}

// CommandIDs returns the "command" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommandID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) CommandIDs() (ids []int64) {
	if id := m.command; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCommand resets all changes to the "command" edge.
func (m *MessageMutation) ResetCommand() {
	m.command = nil
	m.clearedcommand = false
}

// Where appends a list predicates to the MessageMutation builder.
func (m *MessageMutation) Where(ps ...predicate.Message) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Message, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Message).
func (m *MessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.command != nil {
		fields = append(fields, message.FieldCommandID)
	}
	if m._type != nil {
		fields = append(fields, message.FieldType)
	}
	if m.message != nil {
		fields = append(fields, message.FieldMessage)
	}
	if m.created_at != nil {
		fields = append(fields, message.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case message.FieldCommandID:
		return m.CommandID()
	case message.FieldType:
		return m.GetType()
	case message.FieldMessage:
		return m.Message()
	case message.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case message.FieldCommandID:
		return m.OldCommandID(ctx)
	case message.FieldType:
		return m.OldType(ctx)
	case message.FieldMessage:
		return m.OldMessage(ctx)
	case message.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Message field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case message.FieldCommandID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommandID(v)
		return nil
	case message.FieldType:
		v, ok := value.(shared.TaskMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case message.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case message.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Message numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Message nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageMutation) ResetField(name string) error {
	switch name {
	case message.FieldCommandID:
		m.ResetCommandID()
		return nil
	case message.FieldType:
		m.ResetType()
		return nil
	case message.FieldMessage:
		m.ResetMessage()
		return nil
	case message.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.command != nil {
		edges = append(edges, message.EdgeCommand)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeCommand:
		if id := m.command; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcommand {
		edges = append(edges, message.EdgeCommand)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageMutation) EdgeCleared(name string) bool {
	switch name {
	case message.EdgeCommand:
		return m.clearedcommand
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageMutation) ClearEdge(name string) error {
	switch name {
	case message.EdgeCommand:
		m.ClearCommand()
		return nil
	}
	return fmt.Errorf("unknown Message unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageMutation) ResetEdge(name string) error {
	switch name {
	case message.EdgeCommand:
		m.ResetCommand()
		return nil
	}
	return fmt.Errorf("unknown Message edge %s", name)
}

// OperatorMutation represents an operation that mutates the Operator nodes in the graph.
type OperatorMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	username       *string
	token          *string
	color          *uint32
	addcolor       *int32
	last           *time.Time
	clearedFields  map[string]struct{}
	chat           map[int]struct{}
	removedchat    map[int]struct{}
	clearedchat    bool
	command        map[int64]struct{}
	removedcommand map[int64]struct{}
	clearedcommand bool
	done           bool
	oldValue       func(context.Context) (*Operator, error)
	predicates     []predicate.Operator
}

var _ ent.Mutation = (*OperatorMutation)(nil)

// operatorOption allows management of the mutation configuration using functional options.
type operatorOption func(*OperatorMutation)

// newOperatorMutation creates new mutation for the Operator entity.
func newOperatorMutation(c config, op Op, opts ...operatorOption) *OperatorMutation {
	m := &OperatorMutation{
		config:        c,
		op:            op,
		typ:           TypeOperator,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOperatorID sets the ID field of the mutation.
func withOperatorID(id int64) operatorOption {
	return func(m *OperatorMutation) {
		var (
			err   error
			once  sync.Once
			value *Operator
		)
		m.oldValue = func(ctx context.Context) (*Operator, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Operator.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOperator sets the old Operator of the mutation.
func withOperator(node *Operator) operatorOption {
	return func(m *OperatorMutation) {
		m.oldValue = func(context.Context) (*Operator, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OperatorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OperatorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Operator entities.
func (m *OperatorMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OperatorMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OperatorMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Operator.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OperatorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OperatorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Operator entity.
// If the Operator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OperatorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OperatorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OperatorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Operator entity.
// If the Operator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OperatorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OperatorMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OperatorMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Operator entity.
// If the Operator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatorMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OperatorMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[operator.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OperatorMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[operator.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OperatorMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, operator.FieldDeletedAt)
}

// SetUsername sets the "username" field.
func (m *OperatorMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *OperatorMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Operator entity.
// If the Operator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatorMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *OperatorMutation) ResetUsername() {
	m.username = nil
}

// SetToken sets the "token" field.
func (m *OperatorMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *OperatorMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Operator entity.
// If the Operator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatorMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ClearToken clears the value of the "token" field.
func (m *OperatorMutation) ClearToken() {
	m.token = nil
	m.clearedFields[operator.FieldToken] = struct{}{}
}

// TokenCleared returns if the "token" field was cleared in this mutation.
func (m *OperatorMutation) TokenCleared() bool {
	_, ok := m.clearedFields[operator.FieldToken]
	return ok
}

// ResetToken resets all changes to the "token" field.
func (m *OperatorMutation) ResetToken() {
	m.token = nil
	delete(m.clearedFields, operator.FieldToken)
}

// SetColor sets the "color" field.
func (m *OperatorMutation) SetColor(u uint32) {
	m.color = &u
	m.addcolor = nil
}

// Color returns the value of the "color" field in the mutation.
func (m *OperatorMutation) Color() (r uint32, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Operator entity.
// If the Operator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatorMutation) OldColor(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// AddColor adds u to the "color" field.
func (m *OperatorMutation) AddColor(u int32) {
	if m.addcolor != nil {
		*m.addcolor += u
	} else {
		m.addcolor = &u
	}
}

// AddedColor returns the value that was added to the "color" field in this mutation.
func (m *OperatorMutation) AddedColor() (r int32, exists bool) {
	v := m.addcolor
	if v == nil {
		return
	}
	return *v, true
}

// ResetColor resets all changes to the "color" field.
func (m *OperatorMutation) ResetColor() {
	m.color = nil
	m.addcolor = nil
}

// SetLast sets the "last" field.
func (m *OperatorMutation) SetLast(t time.Time) {
	m.last = &t
}

// Last returns the value of the "last" field in the mutation.
func (m *OperatorMutation) Last() (r time.Time, exists bool) {
	v := m.last
	if v == nil {
		return
	}
	return *v, true
}

// OldLast returns the old "last" field's value of the Operator entity.
// If the Operator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatorMutation) OldLast(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLast is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLast requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLast: %w", err)
	}
	return oldValue.Last, nil
}

// ResetLast resets all changes to the "last" field.
func (m *OperatorMutation) ResetLast() {
	m.last = nil
}

// AddChatIDs adds the "chat" edge to the Chat entity by ids.
func (m *OperatorMutation) AddChatIDs(ids ...int) {
	if m.chat == nil {
		m.chat = make(map[int]struct{})
	}
	for i := range ids {
		m.chat[ids[i]] = struct{}{}
	}
}

// ClearChat clears the "chat" edge to the Chat entity.
func (m *OperatorMutation) ClearChat() {
	m.clearedchat = true
}

// ChatCleared reports if the "chat" edge to the Chat entity was cleared.
func (m *OperatorMutation) ChatCleared() bool {
	return m.clearedchat
}

// RemoveChatIDs removes the "chat" edge to the Chat entity by IDs.
func (m *OperatorMutation) RemoveChatIDs(ids ...int) {
	if m.removedchat == nil {
		m.removedchat = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.chat, ids[i])
		m.removedchat[ids[i]] = struct{}{}
	}
}

// RemovedChat returns the removed IDs of the "chat" edge to the Chat entity.
func (m *OperatorMutation) RemovedChatIDs() (ids []int) {
	for id := range m.removedchat {
		ids = append(ids, id)
	}
	return
}

// ChatIDs returns the "chat" edge IDs in the mutation.
func (m *OperatorMutation) ChatIDs() (ids []int) {
	for id := range m.chat {
		ids = append(ids, id)
	}
	return
}

// ResetChat resets all changes to the "chat" edge.
func (m *OperatorMutation) ResetChat() {
	m.chat = nil
	m.clearedchat = false
	m.removedchat = nil
}

// AddCommandIDs adds the "command" edge to the Command entity by ids.
func (m *OperatorMutation) AddCommandIDs(ids ...int64) {
	if m.command == nil {
		m.command = make(map[int64]struct{})
	}
	for i := range ids {
		m.command[ids[i]] = struct{}{}
	}
}

// ClearCommand clears the "command" edge to the Command entity.
func (m *OperatorMutation) ClearCommand() {
	m.clearedcommand = true
}

// CommandCleared reports if the "command" edge to the Command entity was cleared.
func (m *OperatorMutation) CommandCleared() bool {
	return m.clearedcommand
}

// RemoveCommandIDs removes the "command" edge to the Command entity by IDs.
func (m *OperatorMutation) RemoveCommandIDs(ids ...int64) {
	if m.removedcommand == nil {
		m.removedcommand = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.command, ids[i])
		m.removedcommand[ids[i]] = struct{}{}
	}
}

// RemovedCommand returns the removed IDs of the "command" edge to the Command entity.
func (m *OperatorMutation) RemovedCommandIDs() (ids []int64) {
	for id := range m.removedcommand {
		ids = append(ids, id)
	}
	return
}

// CommandIDs returns the "command" edge IDs in the mutation.
func (m *OperatorMutation) CommandIDs() (ids []int64) {
	for id := range m.command {
		ids = append(ids, id)
	}
	return
}

// ResetCommand resets all changes to the "command" edge.
func (m *OperatorMutation) ResetCommand() {
	m.command = nil
	m.clearedcommand = false
	m.removedcommand = nil
}

// Where appends a list predicates to the OperatorMutation builder.
func (m *OperatorMutation) Where(ps ...predicate.Operator) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OperatorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OperatorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Operator, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OperatorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OperatorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Operator).
func (m *OperatorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OperatorMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, operator.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, operator.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, operator.FieldDeletedAt)
	}
	if m.username != nil {
		fields = append(fields, operator.FieldUsername)
	}
	if m.token != nil {
		fields = append(fields, operator.FieldToken)
	}
	if m.color != nil {
		fields = append(fields, operator.FieldColor)
	}
	if m.last != nil {
		fields = append(fields, operator.FieldLast)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OperatorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case operator.FieldCreatedAt:
		return m.CreatedAt()
	case operator.FieldUpdatedAt:
		return m.UpdatedAt()
	case operator.FieldDeletedAt:
		return m.DeletedAt()
	case operator.FieldUsername:
		return m.Username()
	case operator.FieldToken:
		return m.Token()
	case operator.FieldColor:
		return m.Color()
	case operator.FieldLast:
		return m.Last()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OperatorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case operator.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case operator.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case operator.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case operator.FieldUsername:
		return m.OldUsername(ctx)
	case operator.FieldToken:
		return m.OldToken(ctx)
	case operator.FieldColor:
		return m.OldColor(ctx)
	case operator.FieldLast:
		return m.OldLast(ctx)
	}
	return nil, fmt.Errorf("unknown Operator field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OperatorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case operator.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case operator.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case operator.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case operator.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case operator.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case operator.FieldColor:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case operator.FieldLast:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLast(v)
		return nil
	}
	return fmt.Errorf("unknown Operator field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OperatorMutation) AddedFields() []string {
	var fields []string
	if m.addcolor != nil {
		fields = append(fields, operator.FieldColor)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OperatorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case operator.FieldColor:
		return m.AddedColor()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OperatorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case operator.FieldColor:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddColor(v)
		return nil
	}
	return fmt.Errorf("unknown Operator numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OperatorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(operator.FieldDeletedAt) {
		fields = append(fields, operator.FieldDeletedAt)
	}
	if m.FieldCleared(operator.FieldToken) {
		fields = append(fields, operator.FieldToken)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OperatorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OperatorMutation) ClearField(name string) error {
	switch name {
	case operator.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case operator.FieldToken:
		m.ClearToken()
		return nil
	}
	return fmt.Errorf("unknown Operator nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OperatorMutation) ResetField(name string) error {
	switch name {
	case operator.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case operator.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case operator.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case operator.FieldUsername:
		m.ResetUsername()
		return nil
	case operator.FieldToken:
		m.ResetToken()
		return nil
	case operator.FieldColor:
		m.ResetColor()
		return nil
	case operator.FieldLast:
		m.ResetLast()
		return nil
	}
	return fmt.Errorf("unknown Operator field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OperatorMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.chat != nil {
		edges = append(edges, operator.EdgeChat)
	}
	if m.command != nil {
		edges = append(edges, operator.EdgeCommand)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OperatorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case operator.EdgeChat:
		ids := make([]ent.Value, 0, len(m.chat))
		for id := range m.chat {
			ids = append(ids, id)
		}
		return ids
	case operator.EdgeCommand:
		ids := make([]ent.Value, 0, len(m.command))
		for id := range m.command {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OperatorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedchat != nil {
		edges = append(edges, operator.EdgeChat)
	}
	if m.removedcommand != nil {
		edges = append(edges, operator.EdgeCommand)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OperatorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case operator.EdgeChat:
		ids := make([]ent.Value, 0, len(m.removedchat))
		for id := range m.removedchat {
			ids = append(ids, id)
		}
		return ids
	case operator.EdgeCommand:
		ids := make([]ent.Value, 0, len(m.removedcommand))
		for id := range m.removedcommand {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OperatorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedchat {
		edges = append(edges, operator.EdgeChat)
	}
	if m.clearedcommand {
		edges = append(edges, operator.EdgeCommand)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OperatorMutation) EdgeCleared(name string) bool {
	switch name {
	case operator.EdgeChat:
		return m.clearedchat
	case operator.EdgeCommand:
		return m.clearedcommand
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OperatorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Operator unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OperatorMutation) ResetEdge(name string) error {
	switch name {
	case operator.EdgeChat:
		m.ResetChat()
		return nil
	case operator.EdgeCommand:
		m.ResetCommand()
		return nil
	}
	return fmt.Errorf("unknown Operator edge %s", name)
}

// PkiMutation represents an operation that mutates the Pki nodes in the graph.
type PkiMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	_type         *pki.Type
	key           *[]byte
	cert          *[]byte
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Pki, error)
	predicates    []predicate.Pki
}

var _ ent.Mutation = (*PkiMutation)(nil)

// pkiOption allows management of the mutation configuration using functional options.
type pkiOption func(*PkiMutation)

// newPkiMutation creates new mutation for the Pki entity.
func newPkiMutation(c config, op Op, opts ...pkiOption) *PkiMutation {
	m := &PkiMutation{
		config:        c,
		op:            op,
		typ:           TypePki,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPkiID sets the ID field of the mutation.
func withPkiID(id int) pkiOption {
	return func(m *PkiMutation) {
		var (
			err   error
			once  sync.Once
			value *Pki
		)
		m.oldValue = func(ctx context.Context) (*Pki, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Pki.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPki sets the old Pki of the mutation.
func withPki(node *Pki) pkiOption {
	return func(m *PkiMutation) {
		m.oldValue = func(context.Context) (*Pki, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PkiMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PkiMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PkiMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PkiMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Pki.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PkiMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PkiMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Pki entity.
// If the Pki object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkiMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PkiMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PkiMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PkiMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Pki entity.
// If the Pki object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkiMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PkiMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PkiMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PkiMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Pki entity.
// If the Pki object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkiMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PkiMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[pki.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PkiMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[pki.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PkiMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, pki.FieldDeletedAt)
}

// SetType sets the "type" field.
func (m *PkiMutation) SetType(pk pki.Type) {
	m._type = &pk
}

// GetType returns the value of the "type" field in the mutation.
func (m *PkiMutation) GetType() (r pki.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Pki entity.
// If the Pki object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkiMutation) OldType(ctx context.Context) (v pki.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PkiMutation) ResetType() {
	m._type = nil
}

// SetKey sets the "key" field.
func (m *PkiMutation) SetKey(b []byte) {
	m.key = &b
}

// Key returns the value of the "key" field in the mutation.
func (m *PkiMutation) Key() (r []byte, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Pki entity.
// If the Pki object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkiMutation) OldKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *PkiMutation) ResetKey() {
	m.key = nil
}

// SetCert sets the "cert" field.
func (m *PkiMutation) SetCert(b []byte) {
	m.cert = &b
}

// Cert returns the value of the "cert" field in the mutation.
func (m *PkiMutation) Cert() (r []byte, exists bool) {
	v := m.cert
	if v == nil {
		return
	}
	return *v, true
}

// OldCert returns the old "cert" field's value of the Pki entity.
// If the Pki object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PkiMutation) OldCert(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCert is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCert requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCert: %w", err)
	}
	return oldValue.Cert, nil
}

// ResetCert resets all changes to the "cert" field.
func (m *PkiMutation) ResetCert() {
	m.cert = nil
}

// Where appends a list predicates to the PkiMutation builder.
func (m *PkiMutation) Where(ps ...predicate.Pki) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PkiMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PkiMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Pki, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PkiMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PkiMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Pki).
func (m *PkiMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PkiMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, pki.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, pki.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, pki.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, pki.FieldType)
	}
	if m.key != nil {
		fields = append(fields, pki.FieldKey)
	}
	if m.cert != nil {
		fields = append(fields, pki.FieldCert)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PkiMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pki.FieldCreatedAt:
		return m.CreatedAt()
	case pki.FieldUpdatedAt:
		return m.UpdatedAt()
	case pki.FieldDeletedAt:
		return m.DeletedAt()
	case pki.FieldType:
		return m.GetType()
	case pki.FieldKey:
		return m.Key()
	case pki.FieldCert:
		return m.Cert()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PkiMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pki.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pki.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case pki.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case pki.FieldType:
		return m.OldType(ctx)
	case pki.FieldKey:
		return m.OldKey(ctx)
	case pki.FieldCert:
		return m.OldCert(ctx)
	}
	return nil, fmt.Errorf("unknown Pki field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PkiMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pki.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pki.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case pki.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case pki.FieldType:
		v, ok := value.(pki.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case pki.FieldKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case pki.FieldCert:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCert(v)
		return nil
	}
	return fmt.Errorf("unknown Pki field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PkiMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PkiMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PkiMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Pki numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PkiMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pki.FieldDeletedAt) {
		fields = append(fields, pki.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PkiMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PkiMutation) ClearField(name string) error {
	switch name {
	case pki.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Pki nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PkiMutation) ResetField(name string) error {
	switch name {
	case pki.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pki.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case pki.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case pki.FieldType:
		m.ResetType()
		return nil
	case pki.FieldKey:
		m.ResetKey()
		return nil
	case pki.FieldCert:
		m.ResetCert()
		return nil
	}
	return fmt.Errorf("unknown Pki field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PkiMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PkiMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PkiMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PkiMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PkiMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PkiMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PkiMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Pki unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PkiMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Pki edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_at            *time.Time
	pushed_at             *time.Time
	done_at               *time.Time
	status                *shared.TaskStatus
	cap                   *shared.Capability
	output_big            *bool
	clearedFields         map[string]struct{}
	command               *int64
	clearedcommand        bool
	agent                 *uint32
	clearedagent          bool
	blobber_args          *int
	clearedblobber_args   bool
	blobber_output        *int
	clearedblobber_output bool
	done                  bool
	oldValue              func(context.Context) (*Task, error)
	predicates            []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id int64) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Task entities.
func (m *TaskMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCommandID sets the "command_id" field.
func (m *TaskMutation) SetCommandID(i int64) {
	m.command = &i
}

// CommandID returns the value of the "command_id" field in the mutation.
func (m *TaskMutation) CommandID() (r int64, exists bool) {
	v := m.command
	if v == nil {
		return
	}
	return *v, true
}

// OldCommandID returns the old "command_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCommandID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommandID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommandID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommandID: %w", err)
	}
	return oldValue.CommandID, nil
}

// ResetCommandID resets all changes to the "command_id" field.
func (m *TaskMutation) ResetCommandID() {
	m.command = nil
}

// SetAgentID sets the "agent_id" field.
func (m *TaskMutation) SetAgentID(u uint32) {
	m.agent = &u
}

// AgentID returns the value of the "agent_id" field in the mutation.
func (m *TaskMutation) AgentID() (r uint32, exists bool) {
	v := m.agent
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentID returns the old "agent_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAgentID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentID: %w", err)
	}
	return oldValue.AgentID, nil
}

// ResetAgentID resets all changes to the "agent_id" field.
func (m *TaskMutation) ResetAgentID() {
	m.agent = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetPushedAt sets the "pushed_at" field.
func (m *TaskMutation) SetPushedAt(t time.Time) {
	m.pushed_at = &t
}

// PushedAt returns the value of the "pushed_at" field in the mutation.
func (m *TaskMutation) PushedAt() (r time.Time, exists bool) {
	v := m.pushed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPushedAt returns the old "pushed_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldPushedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPushedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPushedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPushedAt: %w", err)
	}
	return oldValue.PushedAt, nil
}

// ClearPushedAt clears the value of the "pushed_at" field.
func (m *TaskMutation) ClearPushedAt() {
	m.pushed_at = nil
	m.clearedFields[task.FieldPushedAt] = struct{}{}
}

// PushedAtCleared returns if the "pushed_at" field was cleared in this mutation.
func (m *TaskMutation) PushedAtCleared() bool {
	_, ok := m.clearedFields[task.FieldPushedAt]
	return ok
}

// ResetPushedAt resets all changes to the "pushed_at" field.
func (m *TaskMutation) ResetPushedAt() {
	m.pushed_at = nil
	delete(m.clearedFields, task.FieldPushedAt)
}

// SetDoneAt sets the "done_at" field.
func (m *TaskMutation) SetDoneAt(t time.Time) {
	m.done_at = &t
}

// DoneAt returns the value of the "done_at" field in the mutation.
func (m *TaskMutation) DoneAt() (r time.Time, exists bool) {
	v := m.done_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDoneAt returns the old "done_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDoneAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDoneAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDoneAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoneAt: %w", err)
	}
	return oldValue.DoneAt, nil
}

// ClearDoneAt clears the value of the "done_at" field.
func (m *TaskMutation) ClearDoneAt() {
	m.done_at = nil
	m.clearedFields[task.FieldDoneAt] = struct{}{}
}

// DoneAtCleared returns if the "done_at" field was cleared in this mutation.
func (m *TaskMutation) DoneAtCleared() bool {
	_, ok := m.clearedFields[task.FieldDoneAt]
	return ok
}

// ResetDoneAt resets all changes to the "done_at" field.
func (m *TaskMutation) ResetDoneAt() {
	m.done_at = nil
	delete(m.clearedFields, task.FieldDoneAt)
}

// SetStatus sets the "status" field.
func (m *TaskMutation) SetStatus(ss shared.TaskStatus) {
	m.status = &ss
}

// Status returns the value of the "status" field in the mutation.
func (m *TaskMutation) Status() (r shared.TaskStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldStatus(ctx context.Context) (v shared.TaskStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TaskMutation) ResetStatus() {
	m.status = nil
}

// SetCap sets the "cap" field.
func (m *TaskMutation) SetCap(s shared.Capability) {
	m.cap = &s
}

// Cap returns the value of the "cap" field in the mutation.
func (m *TaskMutation) Cap() (r shared.Capability, exists bool) {
	v := m.cap
	if v == nil {
		return
	}
	return *v, true
}

// OldCap returns the old "cap" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCap(ctx context.Context) (v shared.Capability, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCap is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCap requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCap: %w", err)
	}
	return oldValue.Cap, nil
}

// ResetCap resets all changes to the "cap" field.
func (m *TaskMutation) ResetCap() {
	m.cap = nil
}

// SetArgsID sets the "args_id" field.
func (m *TaskMutation) SetArgsID(i int) {
	m.blobber_args = &i
}

// ArgsID returns the value of the "args_id" field in the mutation.
func (m *TaskMutation) ArgsID() (r int, exists bool) {
	v := m.blobber_args
	if v == nil {
		return
	}
	return *v, true
}

// OldArgsID returns the old "args_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldArgsID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArgsID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArgsID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArgsID: %w", err)
	}
	return oldValue.ArgsID, nil
}

// ResetArgsID resets all changes to the "args_id" field.
func (m *TaskMutation) ResetArgsID() {
	m.blobber_args = nil
}

// SetOutputID sets the "output_id" field.
func (m *TaskMutation) SetOutputID(i int) {
	m.blobber_output = &i
}

// OutputID returns the value of the "output_id" field in the mutation.
func (m *TaskMutation) OutputID() (r int, exists bool) {
	v := m.blobber_output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputID returns the old "output_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldOutputID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputID: %w", err)
	}
	return oldValue.OutputID, nil
}

// ClearOutputID clears the value of the "output_id" field.
func (m *TaskMutation) ClearOutputID() {
	m.blobber_output = nil
	m.clearedFields[task.FieldOutputID] = struct{}{}
}

// OutputIDCleared returns if the "output_id" field was cleared in this mutation.
func (m *TaskMutation) OutputIDCleared() bool {
	_, ok := m.clearedFields[task.FieldOutputID]
	return ok
}

// ResetOutputID resets all changes to the "output_id" field.
func (m *TaskMutation) ResetOutputID() {
	m.blobber_output = nil
	delete(m.clearedFields, task.FieldOutputID)
}

// SetOutputBig sets the "output_big" field.
func (m *TaskMutation) SetOutputBig(b bool) {
	m.output_big = &b
}

// OutputBig returns the value of the "output_big" field in the mutation.
func (m *TaskMutation) OutputBig() (r bool, exists bool) {
	v := m.output_big
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputBig returns the old "output_big" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldOutputBig(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputBig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputBig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputBig: %w", err)
	}
	return oldValue.OutputBig, nil
}

// ClearOutputBig clears the value of the "output_big" field.
func (m *TaskMutation) ClearOutputBig() {
	m.output_big = nil
	m.clearedFields[task.FieldOutputBig] = struct{}{}
}

// OutputBigCleared returns if the "output_big" field was cleared in this mutation.
func (m *TaskMutation) OutputBigCleared() bool {
	_, ok := m.clearedFields[task.FieldOutputBig]
	return ok
}

// ResetOutputBig resets all changes to the "output_big" field.
func (m *TaskMutation) ResetOutputBig() {
	m.output_big = nil
	delete(m.clearedFields, task.FieldOutputBig)
}

// ClearCommand clears the "command" edge to the Command entity.
func (m *TaskMutation) ClearCommand() {
	m.clearedcommand = true
	m.clearedFields[task.FieldCommandID] = struct{}{}
}

// CommandCleared reports if the "command" edge to the Command entity was cleared.
func (m *TaskMutation) CommandCleared() bool {
	return m.clearedcommand
}

// CommandIDs returns the "command" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommandID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) CommandIDs() (ids []int64) {
	if id := m.command; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCommand resets all changes to the "command" edge.
func (m *TaskMutation) ResetCommand() {
	m.command = nil
	m.clearedcommand = false
}

// ClearAgent clears the "agent" edge to the Agent entity.
func (m *TaskMutation) ClearAgent() {
	m.clearedagent = true
	m.clearedFields[task.FieldAgentID] = struct{}{}
}

// AgentCleared reports if the "agent" edge to the Agent entity was cleared.
func (m *TaskMutation) AgentCleared() bool {
	return m.clearedagent
}

// AgentIDs returns the "agent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) AgentIDs() (ids []uint32) {
	if id := m.agent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgent resets all changes to the "agent" edge.
func (m *TaskMutation) ResetAgent() {
	m.agent = nil
	m.clearedagent = false
}

// SetBlobberArgsID sets the "blobber_args" edge to the Blobber entity by id.
func (m *TaskMutation) SetBlobberArgsID(id int) {
	m.blobber_args = &id
}

// ClearBlobberArgs clears the "blobber_args" edge to the Blobber entity.
func (m *TaskMutation) ClearBlobberArgs() {
	m.clearedblobber_args = true
	m.clearedFields[task.FieldArgsID] = struct{}{}
}

// BlobberArgsCleared reports if the "blobber_args" edge to the Blobber entity was cleared.
func (m *TaskMutation) BlobberArgsCleared() bool {
	return m.clearedblobber_args
}

// BlobberArgsID returns the "blobber_args" edge ID in the mutation.
func (m *TaskMutation) BlobberArgsID() (id int, exists bool) {
	if m.blobber_args != nil {
		return *m.blobber_args, true
	}
	return
}

// BlobberArgsIDs returns the "blobber_args" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlobberArgsID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) BlobberArgsIDs() (ids []int) {
	if id := m.blobber_args; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlobberArgs resets all changes to the "blobber_args" edge.
func (m *TaskMutation) ResetBlobberArgs() {
	m.blobber_args = nil
	m.clearedblobber_args = false
}

// SetBlobberOutputID sets the "blobber_output" edge to the Blobber entity by id.
func (m *TaskMutation) SetBlobberOutputID(id int) {
	m.blobber_output = &id
}

// ClearBlobberOutput clears the "blobber_output" edge to the Blobber entity.
func (m *TaskMutation) ClearBlobberOutput() {
	m.clearedblobber_output = true
	m.clearedFields[task.FieldOutputID] = struct{}{}
}

// BlobberOutputCleared reports if the "blobber_output" edge to the Blobber entity was cleared.
func (m *TaskMutation) BlobberOutputCleared() bool {
	return m.OutputIDCleared() || m.clearedblobber_output
}

// BlobberOutputID returns the "blobber_output" edge ID in the mutation.
func (m *TaskMutation) BlobberOutputID() (id int, exists bool) {
	if m.blobber_output != nil {
		return *m.blobber_output, true
	}
	return
}

// BlobberOutputIDs returns the "blobber_output" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlobberOutputID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) BlobberOutputIDs() (ids []int) {
	if id := m.blobber_output; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlobberOutput resets all changes to the "blobber_output" edge.
func (m *TaskMutation) ResetBlobberOutput() {
	m.blobber_output = nil
	m.clearedblobber_output = false
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Task, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.command != nil {
		fields = append(fields, task.FieldCommandID)
	}
	if m.agent != nil {
		fields = append(fields, task.FieldAgentID)
	}
	if m.created_at != nil {
		fields = append(fields, task.FieldCreatedAt)
	}
	if m.pushed_at != nil {
		fields = append(fields, task.FieldPushedAt)
	}
	if m.done_at != nil {
		fields = append(fields, task.FieldDoneAt)
	}
	if m.status != nil {
		fields = append(fields, task.FieldStatus)
	}
	if m.cap != nil {
		fields = append(fields, task.FieldCap)
	}
	if m.blobber_args != nil {
		fields = append(fields, task.FieldArgsID)
	}
	if m.blobber_output != nil {
		fields = append(fields, task.FieldOutputID)
	}
	if m.output_big != nil {
		fields = append(fields, task.FieldOutputBig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldCommandID:
		return m.CommandID()
	case task.FieldAgentID:
		return m.AgentID()
	case task.FieldCreatedAt:
		return m.CreatedAt()
	case task.FieldPushedAt:
		return m.PushedAt()
	case task.FieldDoneAt:
		return m.DoneAt()
	case task.FieldStatus:
		return m.Status()
	case task.FieldCap:
		return m.Cap()
	case task.FieldArgsID:
		return m.ArgsID()
	case task.FieldOutputID:
		return m.OutputID()
	case task.FieldOutputBig:
		return m.OutputBig()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldCommandID:
		return m.OldCommandID(ctx)
	case task.FieldAgentID:
		return m.OldAgentID(ctx)
	case task.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case task.FieldPushedAt:
		return m.OldPushedAt(ctx)
	case task.FieldDoneAt:
		return m.OldDoneAt(ctx)
	case task.FieldStatus:
		return m.OldStatus(ctx)
	case task.FieldCap:
		return m.OldCap(ctx)
	case task.FieldArgsID:
		return m.OldArgsID(ctx)
	case task.FieldOutputID:
		return m.OldOutputID(ctx)
	case task.FieldOutputBig:
		return m.OldOutputBig(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldCommandID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommandID(v)
		return nil
	case task.FieldAgentID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentID(v)
		return nil
	case task.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case task.FieldPushedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPushedAt(v)
		return nil
	case task.FieldDoneAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoneAt(v)
		return nil
	case task.FieldStatus:
		v, ok := value.(shared.TaskStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case task.FieldCap:
		v, ok := value.(shared.Capability)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCap(v)
		return nil
	case task.FieldArgsID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArgsID(v)
		return nil
	case task.FieldOutputID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputID(v)
		return nil
	case task.FieldOutputBig:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputBig(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(task.FieldPushedAt) {
		fields = append(fields, task.FieldPushedAt)
	}
	if m.FieldCleared(task.FieldDoneAt) {
		fields = append(fields, task.FieldDoneAt)
	}
	if m.FieldCleared(task.FieldOutputID) {
		fields = append(fields, task.FieldOutputID)
	}
	if m.FieldCleared(task.FieldOutputBig) {
		fields = append(fields, task.FieldOutputBig)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	switch name {
	case task.FieldPushedAt:
		m.ClearPushedAt()
		return nil
	case task.FieldDoneAt:
		m.ClearDoneAt()
		return nil
	case task.FieldOutputID:
		m.ClearOutputID()
		return nil
	case task.FieldOutputBig:
		m.ClearOutputBig()
		return nil
	}
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldCommandID:
		m.ResetCommandID()
		return nil
	case task.FieldAgentID:
		m.ResetAgentID()
		return nil
	case task.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case task.FieldPushedAt:
		m.ResetPushedAt()
		return nil
	case task.FieldDoneAt:
		m.ResetDoneAt()
		return nil
	case task.FieldStatus:
		m.ResetStatus()
		return nil
	case task.FieldCap:
		m.ResetCap()
		return nil
	case task.FieldArgsID:
		m.ResetArgsID()
		return nil
	case task.FieldOutputID:
		m.ResetOutputID()
		return nil
	case task.FieldOutputBig:
		m.ResetOutputBig()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.command != nil {
		edges = append(edges, task.EdgeCommand)
	}
	if m.agent != nil {
		edges = append(edges, task.EdgeAgent)
	}
	if m.blobber_args != nil {
		edges = append(edges, task.EdgeBlobberArgs)
	}
	if m.blobber_output != nil {
		edges = append(edges, task.EdgeBlobberOutput)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeCommand:
		if id := m.command; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeAgent:
		if id := m.agent; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeBlobberArgs:
		if id := m.blobber_args; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeBlobberOutput:
		if id := m.blobber_output; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcommand {
		edges = append(edges, task.EdgeCommand)
	}
	if m.clearedagent {
		edges = append(edges, task.EdgeAgent)
	}
	if m.clearedblobber_args {
		edges = append(edges, task.EdgeBlobberArgs)
	}
	if m.clearedblobber_output {
		edges = append(edges, task.EdgeBlobberOutput)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	switch name {
	case task.EdgeCommand:
		return m.clearedcommand
	case task.EdgeAgent:
		return m.clearedagent
	case task.EdgeBlobberArgs:
		return m.clearedblobber_args
	case task.EdgeBlobberOutput:
		return m.clearedblobber_output
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	switch name {
	case task.EdgeCommand:
		m.ClearCommand()
		return nil
	case task.EdgeAgent:
		m.ClearAgent()
		return nil
	case task.EdgeBlobberArgs:
		m.ClearBlobberArgs()
		return nil
	case task.EdgeBlobberOutput:
		m.ClearBlobberOutput()
		return nil
	}
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	switch name {
	case task.EdgeCommand:
		m.ResetCommand()
		return nil
	case task.EdgeAgent:
		m.ResetAgent()
		return nil
	case task.EdgeBlobberArgs:
		m.ResetBlobberArgs()
		return nil
	case task.EdgeBlobberOutput:
		m.ResetBlobberOutput()
		return nil
	}
	return fmt.Errorf("unknown Task edge %s", name)
}
